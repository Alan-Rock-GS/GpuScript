
  #include "UnityCG.cginc"
  #include "Lighting.cginc"
  #include "../../GS/GS_Compute.cginc"
  #define BasisType_Pow2	0
  #define BasisType_Linear	1
  #define BasisType_Cubic	2
  #define BasisType_Exp	3
  #define UInts_missingInputs	0
  #define UInts_missingOutputs	1
  #define UInts_best_score	2
  #define UInts_best_scoreI	3
  #define UInts_mxScore	4
  #define UInts_mnScore	5
  #define UInts_mxScoreI	6
  #define UInts_mnScoreI	7
  #define UInts_sum_w	8
  #define UInts_maxError	9
  #define UInts_maxErrorI	10
  #define UInts_maxOutlier	11
  #define UInts_maxOutlierI	12
  #define UInts_max_fp	13
  #define UInts_max_fpI	14
  #define UInts_N	15
  #define Find_Mode_Unknowns	0
  #define Find_Mode_K_U	1
  #define Find_Mode_Outliers	2
  #define g gGEM_Lib[0]
  #pragma use_dxc
  struct GGEM_Lib
  {
    uint AppendBuff_IndexN, AppendBuff_BitN, AppendBuff_N, AppendBuff_BitN1, AppendBuff_BitN2, Rand_N, Rand_I, Rand_J, xN, yN, tstN, trnN, levelI, levelN, searchPntN, basisType, findMode, unknownN, K_UN, outlierN, outlier_errorN, outlier_y_error_IndexN, fpN;
    uint4 Rand_seed4;
    float tolerance, minBasisWidth, maxBasisWidth, basisStep, basisWidth, searchRadius, searchStep, bestScore, bestIterationScore, outlier_tolerance, fp_tolerance;
  };
  groupshared uint4 Rand_grp[1024];
  groupshared uint AppendBuff_grp[1024];
  groupshared uint AppendBuff_grp0[1024];
  RWStructuredBuffer<GGEM_Lib> gGEM_Lib;
  RWStructuredBuffer<uint4> Rand_rs;
  RWStructuredBuffer<uint> AppendBuff_Bits, AppendBuff_Sums, AppendBuff_Indexes, AppendBuff_Fills1, AppendBuff_Fills2, uints, scores, maxErrors, unknowns, K_Us, outliers, outlier_errors, fps;
  RWStructuredBuffer<float> tstXs, tstYs, trnXYs, trnCs, searchPnts, bestInputs, tstXs0, tstYs0, trnXs0, trnYs0, w_avg_Xs;
  RWStructuredBuffer<int> ys, Ranges, wx;
  RWStructuredBuffer<float2> ranges, desiredValWeights;
  [numthreads(numthreads1, 1, 1)] void findMaxErrorI(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.tstN) { uint tst_PntI = id.x; if (maxErrors[tst_PntI] == uints[UInts_maxError]) uints[UInts_maxErrorI] = tst_PntI; }
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void findMaxError(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.tstN) { uint tst_PntI = id.x; InterlockedMax(uints, UInts_maxError, maxErrors[tst_PntI]); }
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void initMaxError(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.tstN) { uint tst_PntI = id.x; maxErrors[tst_PntI] = 0; if (tst_PntI == 0) uints[UInts_maxError] = 0; }
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void update_w_avg_Xs(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.xN) { uint xI = id.x; w_avg_Xs[xI] = (wx[xI] / 1e6f) + bestInputs[xI]; }
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void update_best_Score(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < 1) { g.bestIterationScore = scores[uints[UInts_mxScoreI]] / 1e6f; }
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void init_w(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.xN + 1) { uint xI = id.x; if (xI < g.xN) wx[xI] = 0; else uints[UInts_sum_w] = 0; }
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void calc_sum_w(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.searchPntN)
	{
		uint searchI = id.x;
		uint score = scores[searchI], mnScore = scores[uints[UInts_mnScoreI]], mxScore = scores[uints[UInts_mxScoreI]], avgScore = mxScore / 2 + mnScore / 2;
		if (score > avgScore) InterlockedAdd(uints, UInts_sum_w, score - avgScore);
	}
	
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void find_mn_mx_ScoreIs(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < 2 && id.x < g.searchPntN)
	{
		uint searchI = id.x, mI = id.y;
		if (mI == 0) { if (scores[searchI] == uints[UInts_mxScore]) uints[UInts_mxScoreI] = searchI; }
		else { if (scores[searchI] == uints[UInts_mnScore]) uints[UInts_mnScoreI] = searchI; }
	}
	
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void find_mn_mx_Scores(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < 2 && id.x < g.searchPntN)
	{
		uint searchI = id.x, mI = id.y;
		if (mI == 0) InterlockedMax(uints, UInts_mxScore, scores[searchI]); else InterlockedMin(uints, UInts_mnScore, scores[searchI]);
	}
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void inv_Scores(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.searchPntN)
	{
		uint searchI = id.x, mI = id.y;
		uint Score = roundu(rcp(1e-6f * (scores[searchI] + 1)));
		scores[searchI] = Score;
		InterlockedMax(uints, UInts_mxScore, Score);
		InterlockedMin(uints, UInts_mnScore, Score);
	}
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void init_search(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.searchPntN + 3)
	{
		uint i = id.x;
		if (i < g.searchPntN) scores[i] = 0;
		else
		{
			i -= g.searchPntN;
			if (i == 0) uints[UInts_mxScore] = 0; else if (i == 1) uints[UInts_mnScore] = uint_max; else uints[UInts_best_score] = 0;
		}
	}
	
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void init_search_inputs(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < 2 && id.x < g.xN)
	{
		uint xI = id.x, j = id.y;
		float2 dw = desiredValWeights[xI];
		if (j == 0) bestInputs[xI] = dw.y >= 0.99f ? dw.x : 0.5f;
		else w_avg_Xs[xI] = dw.x;
	}
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void initMissingEntries(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < 2) { uints[id.x] = 0; }
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void Copy_Ranges_To_ranges(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.xN + g.yN) { uint i = id.x; ranges[i] = float2(Ranges[i * 2], Ranges[i * 2 + 1]) / 100000.0f; }
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void Init_Ranges(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.xN + g.yN) { uint i = id.x; Ranges[i * 2] = int_max; Ranges[i * 2 + 1] = int_min; }
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void assign_outliers(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.outlierN) { uint i = id.x; outliers[i] = AppendBuff_Indexes[i]; }
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void assign_K_Us(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.K_UN) { uint i = id.x; K_Us[i] = AppendBuff_Indexes[i]; }
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void assign_unknowns(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.unknownN) { uint i = id.x; unknowns[i] = AppendBuff_Indexes[i]; }
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void find_max_fpI(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.tstN) { uint i = id.x; if (uints[UInts_maxOutlier] == outlier_errors[i]) uints[UInts_maxOutlierI] = i; }
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void calc_max_fp(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.tstN) { uint i = id.x; InterlockedMax(uints, UInts_maxOutlier, outlier_errors[i]); }
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void init_max_fp(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < 1) { uints[UInts_maxOutlier] = 0; uints[UInts_maxOutlierI] = 0; }
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void init_fp_errors(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.tstN) { outlier_errors[id.x] = 0; }
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void Rand_initSeed(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.Rand_N) { uint i = id.x; Rand_rs[i] = i == 0 ? g.Rand_seed4 : u0000; } } }
  [numthreads(numthreads1, 1, 1)] void AppendBuff_GetIndexes(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.AppendBuff_BitN) { uint i = id.x, j, sum = i == 0 ? 0 : AppendBuff_Sums[i - 1], b, i32 = i << 5, k; for (k = 0, b = AppendBuff_Bits[i]; b > 0; k++) { j = (uint)findLSB(b); AppendBuff_Indexes[sum + k] = i32 + j; b = SetBitu(b, j, 0); } } } }
  [numthreads(numthreads1, 1, 1)] void AppendBuff_IncSums(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.AppendBuff_BitN) { uint i = id.x; if (i >= numthreads1) AppendBuff_Sums[i] += AppendBuff_Fills1[i / numthreads1 - 1]; if (i == g.AppendBuff_BitN - 1) g.AppendBuff_IndexN = AppendBuff_Sums[i]; } } }
  [numthreads(numthreads1, 1, 1)] void AppendBuff_IncFills1(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.AppendBuff_BitN1) { uint i = id.x; if (i >= numthreads1) AppendBuff_Fills1[i] += AppendBuff_Fills2[i / numthreads1 - 1]; } } }
  [numthreads(numthreads1, 1, 1)] void AppendBuff_GetFills2(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
  {
    uint i = id.x, k = i + 1, j = k * numthreads1 - 1, c = i < g.AppendBuff_BitN2 - 1 ? AppendBuff_Fills1[j] : i < g.AppendBuff_BitN2 ? AppendBuff_Fills1[g.AppendBuff_BitN1 - 1] : 0, s;
    AppendBuff_grp0[grpI] = c; AppendBuff_grp[grpI] = c; GroupMemoryBarrierWithGroupSync();
    for (s = 1; s < numthreads1; s *= 2)
    {
      if (grpI >= s && i < g.AppendBuff_BitN2) AppendBuff_grp[grpI] = AppendBuff_grp0[grpI] + AppendBuff_grp0[grpI - s]; GroupMemoryBarrierWithGroupSync();
      AppendBuff_grp0[grpI] = AppendBuff_grp[grpI]; GroupMemoryBarrierWithGroupSync();
    }
    if (i < g.AppendBuff_BitN2) AppendBuff_Fills2[i] = AppendBuff_grp[grpI];
  }
  [numthreads(numthreads1, 1, 1)] void AppendBuff_GetFills1(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
  {
    uint i = id.x, k = i + 1, j = k * numthreads1 - 1, c = i < g.AppendBuff_BitN1 - 1 ? AppendBuff_Sums[j] : i < g.AppendBuff_BitN1 ? AppendBuff_Sums[g.AppendBuff_BitN - 1] : 0, s;
    AppendBuff_grp0[grpI] = c; AppendBuff_grp[grpI] = c; GroupMemoryBarrierWithGroupSync();
    for (s = 1; s < numthreads1; s *= 2)
    {
      if (grpI >= s && i < g.AppendBuff_BitN1) AppendBuff_grp[grpI] = AppendBuff_grp0[grpI] + AppendBuff_grp0[grpI - s]; GroupMemoryBarrierWithGroupSync();
      AppendBuff_grp0[grpI] = AppendBuff_grp[grpI]; GroupMemoryBarrierWithGroupSync();
    }
    if (i < g.AppendBuff_BitN1) AppendBuff_Fills1[i] = AppendBuff_grp[grpI];
  }
  [numthreads(numthreads1, 1, 1)] void AppendBuff_Get_Bits_Sums(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
  {
    uint i = id.x, c = i < g.AppendBuff_BitN ? countbits(AppendBuff_Bits[i]) : 0, s;
    AppendBuff_grp0[grpI] = c; AppendBuff_grp[grpI] = c; GroupMemoryBarrierWithGroupSync();
    for (s = 1; s < numthreads1; s *= 2)
    {
      if (grpI >= s && i < g.AppendBuff_BitN) AppendBuff_grp[grpI] = AppendBuff_grp0[grpI] + AppendBuff_grp0[grpI - s]; GroupMemoryBarrierWithGroupSync();
      AppendBuff_grp0[grpI] = AppendBuff_grp[grpI]; GroupMemoryBarrierWithGroupSync();
    }
    if (i < g.AppendBuff_BitN) AppendBuff_Sums[i] = AppendBuff_grp[grpI];
  }
  [numthreads(numthreads1, 1, 1)] void Rand_grp_fill_1K(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex) { null; }
  [numthreads(numthreads1, 1, 1)] void Rand_grp_init_1K(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex) { null; }
   
  [numthreads(numthreads1, 1, 1)] void Rand_grp_init_1M(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex) { null; }
   
  uint tstXI(uint _tst_PntI, uint xI) { return _tst_PntI * g.xN + xI; }
  void tstX(uint _tstI, uint xI, float v) { tstXs[tstXI(_tstI, xI)] = v; }
	
  uint tstYI(uint _tst_PntI, uint yI) { return _tst_PntI * g.yN + yI; }
  [numthreads(numthreads3, numthreads3, numthreads3)] void zero_output_ys(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.z < 2 && id.y < g.yN && id.x < g.tstN) { uint _tst_PntI = id.x, yI = id.y, outI = tstYI(_tst_PntI, yI) * 2 + id.z; ys[outI] = 0; }
	
    }
  }
  void tstY(uint _tstI, uint yI, float v) { tstYs[tstYI(_tstI, yI)] = v; }
	
  [numthreads(numthreads2, numthreads2, 1)] void zero_outputs(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.yN && id.x < g.tstN) { uint _tst_PntI = id.x, yI = id.y; tstY(_tst_PntI, yI, 0); }
	
    }
  }
  float tstX_01(uint _tstI, uint xI) { return tstXs[tstXI(_tstI, xI)]; }
  [numthreads(numthreads2, numthreads2, 1)] void normalize_inputs(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.xN && id.x < g.tstN) { uint _tst_PntI = id.x, xI = id.y; tstX(_tst_PntI, xI, lerp1(ranges[xI], tstX_01(_tst_PntI, xI))); }
	
    }
  }
  float tstY(uint _tstI, uint yI) { return tstYs[tstYI(_tstI, yI)]; }
  [numthreads(numthreads2, numthreads2, 1)] void copy_tst_Pnts(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.xN + g.yN && id.x < g.tstN)
	{
		uint tst_PntI = id.x, i = id.y;
		if (i < g.xN) tstXs0[tstXI(tst_PntI, i)] = tstX_01(tst_PntI, i); else tstYs0[tstYI(tst_PntI, i - g.xN)] = tstY(tst_PntI, i - g.xN);
	}
	
    }
  }
  uint trnXI(uint pntI, uint xI) { return pntI * g.xN + xI; }
  void trnX(uint pntI, uint xI, float v) { trnXYs[trnXI(pntI, xI)] = v; }
	
  uint trnCI(uint _levelI, uint pntI, uint yI) { return (_levelI * g.trnN + pntI) * g.yN + yI; }
  void trnC(uint _levelI, uint pntI, uint yI, float v) { trnCs[trnCI(_levelI, pntI, yI)] = v; }
	
  [numthreads(numthreads2, numthreads2, 1)] void move_tst_Pnt_to_pnt(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.xN + g.yN && id.x < g.trnN)
	{
		uint pntI = id.x, i = id.y;
		if (i < g.xN) trnX(pntI, i, pntI < g.trnN - 1 ? trnXs0[trnXI(pntI, i)] : tstXs0[trnXI(uints[UInts_maxErrorI], i)]);
		else trnC(0, pntI, i - g.xN, pntI < g.trnN - 1 ? trnYs0[trnCI(0, pntI, i - g.xN)] : tstYs0[trnCI(0, uints[UInts_maxErrorI], i - g.xN)]);
	}
	
    }
  }
  float trnX(uint pntI, uint xI) { return trnXYs[trnXI(pntI, xI)]; }
  [numthreads(numthreads2, numthreads2, 1)] void copy_pntXs_inputs(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.xN && id.x < g.trnN) { uint pntI = id.x, xI = id.y; tstX(pntI, xI, trnX(pntI, xI)); }
	
    }
  }
  float trnC(uint _levelI, uint pntI, uint yI) { return trnCs[trnCI(_levelI, pntI, yI)]; }
  [numthreads(numthreads2, numthreads2, 1)] void copy_pnts(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.xN + g.yN && id.x < g.trnN)
	{
		uint pntI = id.x, i = id.y;
		if (i < g.xN) trnXs0[trnXI(pntI, i)] = trnX(pntI, i); else trnYs0[trnCI(0, pntI, i - g.xN)] = trnC(0, pntI, i - g.xN);
	}
	
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void copy_pnts_to_tst_Pnts(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.xN + g.yN && id.x < g.trnN) { uint pntI = id.x, i = id.y; if (i < g.xN) tstX(pntI, i, trnX(pntI, i)); else tstY(pntI, i - g.xN, trnC(0, pntI, i - g.xN)); }
	
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void detectMissingEntries(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.xN + g.yN && id.x < g.trnN)
	{
		uint pntI = id.x, i = id.y;
		if (i < g.xN) { if (IsNegInf(trnX(pntI, i))) InterlockedOr(uints, UInts_missingInputs, 1); }
		else { if (IsNegInf(trnC(0, pntI, i - g.xN))) InterlockedOr(uints, UInts_missingOutputs, 1); }
	}
	
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void copy_outputs_pntYs(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.yN && id.x < g.trnN) { uint pntI = id.x, yI = id.y; if (g.levelI + 1 < g.levelN) trnC(g.levelI + 1, pntI, yI, trnC(g.levelI, pntI, yI) - tstY(pntI, yI)); }
	
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void copy_pntYs_outputs(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.yN && id.x < g.trnN) { uint pntI = id.x, yI = id.y; tstY(pntI, yI, trnC(g.levelI, pntI, yI)); }
	
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void normalize_trn_Points(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.xN + g.yN && id.x < g.trnN)
	{
		uint pntI = id.x, xI = id.y, yI = xI - g.xN;
		if (xI < g.xN) { float v = trnX(pntI, xI); if (IsNotNegInf(v)) trnX(pntI, xI, lerp1(ranges[xI], v)); }
		else { float v = trnC(0, pntI, yI); if (IsNotNegInf(v)) trnC(0, pntI, yI, lerp1(ranges[yI + g.xN], v)); }
	}
	
    }
  }
  [numthreads(numthreads1, 1, 1)] void Get_ranges(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.xN + g.yN)
	{
		float2 r = initRange;
		if (id.x < g.xN) { uint xI = id.x; for (uint pntI = 0; pntI < g.trnN; pntI++) { float v = trnX(pntI, xI); if (IsNotNegInf(v)) r = SetRange(r, v); } }
		else { uint yI = id.x - g.xN; for (uint pntI = 0; pntI < g.trnN; pntI++) { float v = trnC(0, pntI, yI); if (IsNotNegInf(v)) r = SetRange(r, v); } }
		ranges[id.x] = r;
	}
	
    }
  }
  uint f2u(float f) { return roundu(f * 1e6f); }
  uint searchPntI(uint pntI, uint xI) { return pntI * g.xN + xI; }
  float searchPntX(uint pntI, uint xI) { return searchPnts[searchPntI(pntI, xI)]; }
  [numthreads(numthreads1, 1, 1)] void update_best_x(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.xN) { uint xI = id.x; bestInputs[xI] = searchPntX(uints[UInts_mxScoreI], xI); }
	
    }
  }
  void searchPntX(uint pntI, uint xI, float v) { searchPnts[searchPntI(pntI, xI)] = v; }
	
  float tstY_v(uint _tstI, uint yI) { return lerp(ranges[g.xN + yI], tstY(_tstI, yI)); }
  [numthreads(numthreads2, numthreads2, 1)] void unNormalize_outputs(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.yN && id.x < g.tstN) { uint _tst_PntI = id.x, yI = id.y; tstY(_tst_PntI, yI, tstY_v(_tst_PntI, yI)); }
	
    }
  }
  float Basis(float dst, float width)
	{
		float v = dst * rcp(width), h = 0.1f, d = 1 - h;
		switch ((uint)g.basisType)
		{
			case BasisType_Pow2: v = max(0.001f, pow2(-sqr(v))); break;
			case BasisType_Exp: v = max(0.001f, exp(-sqr(v))); break;
			case BasisType_Cubic: v = max(h, d - v * (d - 0.5f)); v = v * v * (3 - 2 * v); break;
			case BasisType_Linear: v = max(h, d - v * (d - 0.5f)); break;
		}
		return v;
	}
	
  [numthreads(numthreads3, numthreads3, numthreads3)] void calc_output_ys(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.z < g.yN && id.y < g.trnN && id.x < g.tstN)
	{
		uint _tst_PntI = id.x, pntI = id.y, yI = id.z, xI;
		float dst2;
		for (dst2 = 0, xI = 0; xI < g.xN; xI++) dst2 += sqr(trnX(pntI, xI) - tstX_01(_tst_PntI, xI));
		float weight = Basis(sqrt(dst2), g.basisWidth), y = trnC(g.levelI, pntI, yI);
		float2 valWeight = float2(y * weight, weight);
		int2 V = roundi(valWeight * 1e6f);
		uint outI = tstYI(_tst_PntI, yI) * 2;
		InterlockedAdd(ys, outI, V.x);
		InterlockedAdd(ys, outI + 1, V.y);
	}
	
    }
  }
  float calc_dist2_trn_trn(uint i1, uint i2) { float d = 0; for (uint xI = 0; xI < g.xN; xI++) d += sqr(trnX(i1, xI) - trnX(i2, xI)); return d; }
	
  float Calc_Output_v(float yw, float w) { bool lev0 = g.levelI == 0; return lev0 && w == 0 ? 0 : yw * rcp(lev0 ? w : max(w, 1)); }
	
  [numthreads(numthreads2, numthreads2, 1)] void calc_pntHs(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.yN && id.x < g.trnN)
	{
		uint pntI0 = id.x, yI = id.y;
		float y0 = trnC(g.levelI, pntI0, yI), y1, dst2, weight, y;
		float2 valWeight = f00;
		for (uint pntI = 0; pntI < g.trnN; pntI++)
			if (pntI != pntI0)
			{
				dst2 = calc_dist2_trn_trn(pntI0, pntI);
				weight = Basis(sqrt(dst2), g.basisWidth); y = trnC(g.levelI, pntI, yI);
				valWeight += float2(y * weight, weight);
			}
		weight = Basis(0, g.basisWidth); y = trnC(g.levelI, pntI0, yI);
		valWeight += float2(y * weight, weight);
		y1 = Calc_Output_v(valWeight.x, valWeight.y);
		float error = y0 - y1;
		trnC(g.levelI + 1, pntI0, yI, error);
	}
	
    }
  }
  float Calc_Output_v(uint outputI) { return Calc_Output_v(ys[outputI * 2] * 1e-6f, ys[outputI * 2 + 1] * 1e-6f); }
  [numthreads(numthreads2, numthreads2, 1)] void calc_output_sums(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.yN && id.x < g.tstN)
	{
		uint _tst_PntI = id.x, yI = id.y, outputI = tstYI(_tst_PntI, yI);
		float v = Calc_Output_v(outputI);
		if (g.levelI > 0) v += tstY(_tst_PntI, yI);
		tstY(_tst_PntI, yI, v);
	}
	
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void calc_outputs_01(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.yN && id.x < g.tstN)
	{
		uint _tst_PntI = id.x, yI = id.y, outputI = tstYI(_tst_PntI, yI);
		float v = Calc_Output_v(outputI);
		tstY(_tst_PntI, yI, v);
	}
	
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void calc_outputs_v(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.yN && id.x < g.tstN)
	{
		uint _tst_PntI = id.x, yI = id.y, outputI = tstYI(_tst_PntI, yI);
		float v = Calc_Output_v(outputI);
		v = lerp(ranges[g.xN + yI], v);
		tstY(_tst_PntI, yI, v);
	}
	
    }
  }
  uint trnYI(uint pntI, uint yI) { return g.trnN * g.xN + pntI * g.yN + yI; }
  float Get_tstInput(uint tstI, uint xI) { return tstI / (g.tstN - 1.0f); }
  [numthreads(numthreads2, numthreads2, 1)] void assign_tst_Inputs(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.xN && id.x < g.tstN) { uint _tstI = id.x, xI = id.y; tstX(_tstI, xI, Get_tstInput(_tstI, xI)); }
	
    }
  }
  float trnY(uint pntI, uint yI) { return trnXYs[trnYI(pntI, yI)]; }
  [numthreads(numthreads2, numthreads2, 1)] void calc_fp_errors(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.yN && id.x < g.tstN)
	{
		uint i = id.x, yI = id.y;
		float trn_y = trnY(i, yI), tst_y = tstY(i, yI), e = abs(trn_y - tst_y) / g.yN;
		uint E = roundu(e * 1e6f);
		InterlockedAdd(outlier_errors, i, E);
	}
	
    }
  }
  float Get_tst_Pnt_Output(uint _levelI, float width, uint _tst_PntI, uint yI)
	{
		float2 vw = f00;
		for (uint pntI = 0; pntI < g.trnN; pntI++)
		{
			float dst2 = 0;
			for (uint xI = 0; xI < g.xN; xI++) dst2 += sqr(trnX(pntI, xI) - tstX_01(_tst_PntI, xI));
			float w = Basis(sqrt(dst2), width), y = trnC(_levelI, pntI, yI);
			vw += float2(y * w, w);
		}
		return vw.y == 0 ? 0 : vw.x * rcp(vw.y);
	}
	
  float Get_tst_Pnt_Output(uint _tst_PntI, uint yI)
	{
		float y = 0, width = g.maxBasisWidth;
		for (uint _levelI = 0; _levelI < g.levelN; _levelI++, width *= g.basisStep) y += Get_tst_Pnt_Output(_levelI, width, _tst_PntI, yI);
		return y;
	}
	
  [numthreads(numthreads2, numthreads2, 1)] void calcMaxError(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.yN && id.x < g.tstN)
	{
		uint tst_PntI = id.x, yI = id.y;
		InterlockedMax(maxErrors, tst_PntI, f2u(g.trnN == 0 ? tstY(tst_PntI, yI) : g.trnN == 1 ? abs(1 - tstY(tst_PntI, yI)) : abs(Get_tst_Pnt_Output(tst_PntI, yI) - tstY(tst_PntI, yI))));
	}
	
    }
  }
  bool isInf(float v) { return v == fNegInf || v == fPosInf; }
  bool isNotInf(float v) { return !isInf(v); }
  [numthreads(numthreads2, numthreads2, 1)] void Find_Ranges(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.xN + g.yN && id.x < g.trnN)
	{
		uint pntI = id.x, fldI = id.y, j = fldI * 2;
		float v = fldI < g.xN ? trnXYs[trnXI(pntI, fldI)] : trnXYs[trnYI(pntI, fldI - g.xN)];
		if (isNotInf(v))
		{
			int V = roundi(v * 100000);
			InterlockedMin(Ranges, j, V);
			InterlockedMax(Ranges, j + 1, V);
		}
	}
	
    }
  }
  void Set_trnInput(uint trnI, uint xI, float v) { trnXYs[trnI * g.xN + xI] = v; }
  float Get_trnInput(uint trnI, uint xI) { return trnI; }
  void assign_trnInput(uint trnI, uint xI) { Set_trnInput(trnI, xI, Get_trnInput(trnI, xI)); }
  void Set_trnOutput(uint trnI, uint yI, float v) { uint j = trnI * g.yN + yI; trnXYs[g.trnN * g.xN + j] = v; trnCs[j] = v; }
	
  float Get_trnOutput(uint trnI, uint yI) { return trnI; }
  void assign_trnOutput(uint trnI, uint yI) { Set_trnOutput(trnI, yI, Get_trnOutput(trnI, yI)); }
  [numthreads(numthreads2, numthreads2, 1)] void assign_trn_Inputs_Outputs(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.xN + g.yN && id.x < g.trnN) { uint trnI = id.x, xI = id.y, yI = id.y - g.xN; if (xI < g.xN) assign_trnInput(trnI, xI); else assign_trnOutput(trnI, yI); }
	
    }
  }
  float getSearchOutput(uint _levelI, float width, uint searchI, uint yI)
	{
		float2 vw = f00;
		for (uint pntI = 0; pntI < g.trnN; pntI++)
		{
			float dst2 = 0;
			for (uint xI = 0; xI < g.xN; xI++) dst2 += sqr(trnX(pntI, xI) - searchPntX(searchI, xI));
			float w = Basis(sqrt(dst2), width), y = trnC(_levelI, pntI, yI);
			vw += float2(y * w, w);
		}
		bool lev0 = _levelI == 0;
		return lev0 && vw.y == 0 ? 0 : vw.x * rcp(lev0 ? vw.y : max(vw.y, 1));
	}
	
  float getSearchOutput(uint searchI, uint yI)
	{
		float y = 0, width = g.maxBasisWidth;
		for (uint _levelI = 0; _levelI < g.levelN; _levelI++, width *= g.basisStep) y += getSearchOutput(_levelI, width, searchI, yI);
		return y;
	}
	
  float searchPnt_v(uint pntI, uint xI) { return xI < g.xN ? searchPnts[searchPntI(pntI, xI)] : getSearchOutput(pntI, xI - g.xN); }
  [numthreads(numthreads2, numthreads2, 1)] void calc_wx(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.searchPntN && id.x < g.xN)
	{
		uint xI = id.x, searchI = id.y;
		float dx = bestInputs[xI];
		uint score = scores[searchI], mnScore = scores[uints[UInts_mnScoreI]], mxScore = scores[uints[UInts_mxScoreI]], avgScore = mxScore / 2 + mnScore / 2;
		if (score > avgScore)
		{
			score -= avgScore;
			float x = searchPnt_v(searchI, xI) - dx, w = score / 1e6f, sum_w = uints[UInts_sum_w] / 1e6f;
			int WX = roundi(w * x / sum_w * 1e6f);
			InterlockedAdd(wx, xI, WX);
		}
	}
	
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void calc_Scores(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.xN + g.yN && id.x < g.searchPntN)
	{
		uint searchI = id.x, xyI = id.y;
		float2 vw = desiredValWeights[xyI];
		float v = abs(searchPnt_v(searchI, xyI) - vw.x) * vw.y;
		uint Score = roundu(v * 1e6f);
		InterlockedAdd(scores, searchI, Score);
	}
	
    }
  }
  float trnXY(uint pntI, uint xyI) { return xyI < g.xN ? trnX(pntI, xyI) : trnY(pntI, xyI - g.xN); }
  float trnX_01(uint pntI, uint xI) { return trnXYs[trnXI(pntI, xI)]; }
  float trnY_01(uint pntI, uint yI) { return lerp1(ranges[g.xN + yI], trnXYs[trnYI(pntI, yI)]); }
  float tstY_01(uint _tstI, uint yI) { return lerp1(ranges[g.xN + yI], tstY(_tstI, yI)); }
  bool AppendBuff_IsBitOn(uint i)
	{
		switch ((uint)g.findMode)
		{
			case Find_Mode_Unknowns: { uint n = g.xN + g.yN, pntI = i / n, xyI = i % n; return isInf(trnXY(pntI, xyI)); }
			case Find_Mode_K_U: { bool on = false; for (uint xI = 0; !on && xI < g.xN; xI++) on = isInf(trnXY(i, xI)); if (!(on = !on)) { for (uint yI = 0; on && yI < g.yN; yI++) on = isNotInf(trnXY(i, g.xN + yI)); on = !on; } return on; }
			case Find_Mode_Outliers: default: { uint n = g.xN + g.yN, pntI = i / n, xyI = i % n, yI = xyI - g.xN; return abs(xyI < g.xN ? trnX_01(pntI, xyI) - tstX_01(pntI, xyI) : trnY_01(pntI, yI) - tstY_01(pntI, yI)) > g.outlier_tolerance; }
		}
	}
	
  uint AppendBuff_Assign_Bits(uint i, uint j, uint bits) { return bits | (Is(i < g.AppendBuff_N && AppendBuff_IsBitOn(i)) << (int)j); }
  [numthreads(numthreads1, 1, 1)] void AppendBuff_GetSums(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
  {
    uint i = id.x, c, s, j, k, bits = 0;
    if (i < g.AppendBuff_BitN) { for (j = 0, k = i * 32; j < 32; j++) bits = AppendBuff_Assign_Bits(k + j, j, bits); AppendBuff_Bits[i] = bits; c = countbits(bits); } else c = 0;
    AppendBuff_grp0[grpI] = c; AppendBuff_grp[grpI] = c; GroupMemoryBarrierWithGroupSync();
    for (s = 1; s < numthreads1; s *= 2)
    {
      if (grpI >= s && i < g.AppendBuff_BitN) AppendBuff_grp[grpI] = AppendBuff_grp0[grpI] + AppendBuff_grp0[grpI - s]; GroupMemoryBarrierWithGroupSync();
      AppendBuff_grp0[grpI] = AppendBuff_grp[grpI]; GroupMemoryBarrierWithGroupSync();
    }
    if (i < g.AppendBuff_BitN) AppendBuff_Sums[i] = AppendBuff_grp[grpI];
  }
  [numthreads(numthreads1, 1, 1)] void AppendBuff_Get_Bits(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.AppendBuff_BitN) { uint i = id.x, j, k, bits = 0; if (i < g.AppendBuff_BitN) { for (j = 0, k = i * 32; j < 32; j++) bits = AppendBuff_Assign_Bits(k + j, j, bits); AppendBuff_Bits[i] = bits; } } } }
  uint Rand_UV(uint4 r) { return cxor(r); }
  float Rand_FV(uint4 r) { return 2.3283064365387e-10f * Rand_UV(r); }
  uint Rand_u(uint a, int b, int c, int d, uint e) { return ((a & e) << d) ^ (((a << b) ^ a) >> c); }
  uint4 Rand_U4(uint4 r) { return uint4(Rand_u(r.x, 13, 19, 12, 4294967294u), Rand_u(r.y, 2, 25, 4, 4294967288u), Rand_u(r.z, 3, 11, 17, 4294967280u), r.w * 1664525 + 1013904223u); }
  uint4 Rand_rUInt4(uint i) { return Rand_U4(Rand_rs[i]); }
  uint4 Rand_UInt4(uint i) { return Rand_rs[i] = Rand_rUInt4(i); }
  float Rand_Float(uint i) { return Rand_FV(Rand_UInt4(i)); }
  float Rand_Float(uint i, float A, float B) { return lerp(A, B, Rand_Float(i)); }
  [numthreads(numthreads2, numthreads2, 1)] void find_search_Pnts(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.xN && id.x < g.searchPntN)
	{
		uint searchI = id.x, xI = id.y;
		if (searchI == 0) searchPntX(searchI, xI, w_avg_Xs[xI]);
		else
		{
			float2 dw = desiredValWeights[xI];
			float v = bestInputs[xI], r = g.searchRadius, x = dw.y >= 0.99f ? dw.x : Rand_Float(searchPntI(searchI, xI), max(0, v - r), min(1, v + r));
			searchPntX(searchI, xI, x);
		}
	}
	
    }
  }
  uint Rand_UInt(uint i, uint A, uint B) { return flooru(Rand_Float(i, A, B)); }
  [numthreads(numthreads1, 1, 1)] void Rand_initState(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.Rand_I) { uint i = id.x + g.Rand_I; if (i < g.Rand_N) Rand_rs[i] = index(Rand_rs[i], g.Rand_J, Rand_UInt(id.x, 0, uint_max)); } } }
  [numthreads(numthreads2, numthreads2, 1)] void remove_maxError_tst_Pnt(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.xN + g.yN && id.x < g.tstN)
	{
		uint tst_PntI = id.x, i = id.y, tst_PntJ = tst_PntI + Is(tst_PntI >= uints[UInts_maxErrorI]);
		if (i < g.xN) tstX(tst_PntI, i, tstXs0[tstXI(tst_PntJ, i)]); else tstY(tst_PntI, i - g.xN, tstYs0[tstYI(tst_PntJ, i - g.xN)]);
	}
	
    }
  }
  #pragma kernel remove_maxError_tst_Pnt
  #pragma kernel copy_tst_Pnts
  #pragma kernel move_tst_Pnt_to_pnt
  #pragma kernel copy_pnts
  #pragma kernel findMaxErrorI
  #pragma kernel findMaxError
  #pragma kernel calcMaxError
  #pragma kernel initMaxError
  #pragma kernel copy_pnts_to_tst_Pnts
  #pragma kernel update_w_avg_Xs
  #pragma kernel update_best_x
  #pragma kernel update_best_Score
  #pragma kernel calc_wx
  #pragma kernel init_w
  #pragma kernel calc_sum_w
  #pragma kernel find_mn_mx_ScoreIs
  #pragma kernel find_mn_mx_Scores
  #pragma kernel inv_Scores
  #pragma kernel calc_Scores
  #pragma kernel find_search_Pnts
  #pragma kernel init_search
  #pragma kernel init_search_inputs
  #pragma kernel detectMissingEntries
  #pragma kernel initMissingEntries
  #pragma kernel copy_outputs_pntYs
  #pragma kernel copy_pntYs_outputs
  #pragma kernel copy_pntXs_inputs
  #pragma kernel unNormalize_outputs
  #pragma kernel calc_output_sums
  #pragma kernel calc_outputs_01
  #pragma kernel calc_outputs_v
  #pragma kernel calc_output_ys
  #pragma kernel zero_output_ys
  #pragma kernel zero_outputs
  #pragma kernel normalize_inputs
  #pragma kernel calc_pntHs
  #pragma kernel normalize_trn_Points
  #pragma kernel Get_ranges
  #pragma kernel Copy_Ranges_To_ranges
  #pragma kernel Find_Ranges
  #pragma kernel Init_Ranges
  #pragma kernel assign_trn_Inputs_Outputs
  #pragma kernel assign_tst_Inputs
  #pragma kernel assign_outliers
  #pragma kernel assign_K_Us
  #pragma kernel assign_unknowns
  #pragma kernel find_max_fpI
  #pragma kernel calc_max_fp
  #pragma kernel init_max_fp
  #pragma kernel calc_fp_errors
  #pragma kernel init_fp_errors
  #pragma kernel Rand_initState
  #pragma kernel Rand_initSeed
  #pragma kernel AppendBuff_GetIndexes
  #pragma kernel AppendBuff_IncSums
  #pragma kernel AppendBuff_IncFills1
  #pragma kernel AppendBuff_GetFills2
  #pragma kernel AppendBuff_GetFills1
  #pragma kernel AppendBuff_Get_Bits_Sums
  #pragma kernel AppendBuff_GetSums
  #pragma kernel AppendBuff_Get_Bits
  #pragma kernel Rand_grp_fill_1K
  #pragma kernel Rand_grp_init_1K
  #pragma kernel Rand_grp_init_1M