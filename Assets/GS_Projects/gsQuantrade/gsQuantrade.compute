
  #include "UnityCG.cginc"
  #include "Lighting.cginc"
  #include "../../GS/GS_Compute.cginc"
  #define UseTickers_One	0
  #define UseTickers_All	1
  #define AvgTypes_Avg	0
  #define AvgTypes_Slope	1
  #define AvgTypes_Bend	2
  #define AvgTypes_N	3
  #define RuleScore_slope0	0
  #define RuleScore_slope1	1
  #define RuleScore_slope2	2
  #define RuleScore_bend0	3
  #define RuleScore_bend1	4
  #define RuleScore_bend2	5
  #define ETrade_open	0
  #define ETrade_high	1
  #define ETrade_low	2
  #define ETrade_close	3
  #define ETrade_volume	4
  #define ETrade_N	5
  #define AppendBuffMode_FindTabs	0
  #define AppendBuffMode_FindStartYearIs	1
  #define AppendBuffMode_N	2
  #define VGrid_Lib_BDraw_Draw_Point	0
  #define VGrid_Lib_BDraw_Draw_Sphere	1
  #define VGrid_Lib_BDraw_Draw_Line	2
  #define VGrid_Lib_BDraw_Draw_Arrow	3
  #define VGrid_Lib_BDraw_Draw_Signal	4
  #define VGrid_Lib_BDraw_Draw_LineSegment	5
  #define VGrid_Lib_BDraw_Draw_Texture_2D	6
  #define VGrid_Lib_BDraw_Draw_Quad	7
  #define VGrid_Lib_BDraw_Draw_WebCam	8
  #define VGrid_Lib_BDraw_Draw_Mesh	9
  #define VGrid_Lib_BDraw_Draw_Number	10
  #define VGrid_Lib_BDraw_Draw_N	11
  #define VGrid_Lib_BDraw_TextAlignment_BottomLeft	0
  #define VGrid_Lib_BDraw_TextAlignment_CenterLeft	1
  #define VGrid_Lib_BDraw_TextAlignment_TopLeft	2
  #define VGrid_Lib_BDraw_TextAlignment_BottomCenter	3
  #define VGrid_Lib_BDraw_TextAlignment_CenterCenter	4
  #define VGrid_Lib_BDraw_TextAlignment_TopCenter	5
  #define VGrid_Lib_BDraw_TextAlignment_BottomRight	6
  #define VGrid_Lib_BDraw_TextAlignment_CenterRight	7
  #define VGrid_Lib_BDraw_TextAlignment_TopRight	8
  #define VGrid_Lib_BDraw_Text_QuadType_FrontOnly	0
  #define VGrid_Lib_BDraw_Text_QuadType_FrontBack	1
  #define VGrid_Lib_BDraw_Text_QuadType_Switch	2
  #define VGrid_Lib_BDraw_Text_QuadType_Arrow	3
  #define VGrid_Lib_BDraw_Text_QuadType_Billboard	4
  #define VGrid_Lib_PaletteType_Rainbow	0
  #define VGrid_Lib_PaletteType_GradientRainbow	1
  #define VGrid_Lib_PaletteType_GradientRainbow10	2
  #define VGrid_Lib_PaletteType_GradientRainbow20	3
  #define VGrid_Lib_PaletteType_Heat	4
  #define VGrid_Lib_PaletteType_GradientHeat	5
  #define VGrid_Lib_PaletteType_WhiteRainbow	6
  #define VGrid_Lib_PaletteType_invRainbow	7
  #define VGrid_Lib_PaletteType_Green	8
  #define VGrid_Lib_PaletteType_Gray	9
  #define VGrid_Lib_PaletteType_DarkGray	10
  #define VGrid_Lib_PaletteType_CT	11
  #define Views_Lib_ProjectionMode_Automatic	0
  #define Views_Lib_ProjectionMode_Perspective	1
  #define Views_Lib_ProjectionMode_Orthographic	2
  #define GEM_Lib_BasisType_Pow2	0
  #define GEM_Lib_BasisType_Linear	1
  #define GEM_Lib_BasisType_Cubic	2
  #define GEM_Lib_BasisType_Exp	3
  #define GEM_Lib_UInts_missingInputs	0
  #define GEM_Lib_UInts_missingOutputs	1
  #define GEM_Lib_UInts_best_score	2
  #define GEM_Lib_UInts_best_scoreI	3
  #define GEM_Lib_UInts_mxScore	4
  #define GEM_Lib_UInts_mnScore	5
  #define GEM_Lib_UInts_mxScoreI	6
  #define GEM_Lib_UInts_mnScoreI	7
  #define GEM_Lib_UInts_sum_w	8
  #define GEM_Lib_UInts_maxError	9
  #define GEM_Lib_UInts_maxErrorI	10
  #define GEM_Lib_UInts_maxOutlier	11
  #define GEM_Lib_UInts_maxOutlierI	12
  #define GEM_Lib_UInts_max_fp	13
  #define GEM_Lib_UInts_max_fpI	14
  #define GEM_Lib_UInts_N	15
  #define GEM_Lib_Find_Mode_Unknowns	0
  #define GEM_Lib_Find_Mode_K_U	1
  #define GEM_Lib_Find_Mode_Outliers	2
  #define VGrid_Lib_BDraw_Draw_Text3D 12
  #define VGrid_Lib_BDraw_LF 10
  #define VGrid_Lib_BDraw_TB 9
  #define VGrid_Lib_BDraw_ZERO 48
  #define VGrid_Lib_BDraw_NINE 57
  #define VGrid_Lib_BDraw_PERIOD 46
  #define VGrid_Lib_BDraw_COMMA 44
  #define VGrid_Lib_BDraw_PLUS 43
  #define VGrid_Lib_BDraw_MINUS 45
  #define VGrid_Lib_BDraw_SPACE 32
  #define g gQuantrade[0]
  #pragma use_dxc
  struct GQuantrade
  {
    uint includeOpen, includeHigh, includeLow, includeClose, tickerI, year0, yearI, yearN, year, startTestDayIndex, prevDayN, movingAvgI, movingAvgN, ruleI, ruleN, OpenHighLowCloseN, dateN, dateI, ticker_csv_byte_N, ticker_csv_uint_N, ticker_csv_item_N, ticker_csv_line_N, csvHeaderN, csvColN, appendBuffMode, yearTradeI, tickerN, VGrid_Lib_BDraw_AppendBuff_IndexN, VGrid_Lib_BDraw_AppendBuff_BitN, VGrid_Lib_BDraw_AppendBuff_N, VGrid_Lib_BDraw_AppendBuff_BitN1, VGrid_Lib_BDraw_AppendBuff_BitN2, VGrid_Lib_BDraw_omitText, VGrid_Lib_BDraw_includeUnicode, VGrid_Lib_BDraw_fontInfoN, VGrid_Lib_BDraw_textN, VGrid_Lib_BDraw_textCharN, VGrid_Lib_BDraw_boxEdgeN, VGrid_Lib_drawGrid, VGrid_Lib_drawBox, VGrid_Lib_drawAxes, VGrid_Lib_customAxesRangeN, VGrid_Lib_zeroOrigin, VGrid_Lib_drawSurface, VGrid_Lib_GridDrawFront, VGrid_Lib_GridDrawBack, VGrid_Lib_show_slices, VGrid_Lib_paletteType, VGrid_Lib_twoSided, VGrid_Lib_reCalc, VGrid_Lib_buildText, VGrid_Lib_isOrtho, VGrid_Lib_showMeshVal, VGrid_Lib_showMeshRange, VGrid_Lib_showOutline, VGrid_Lib_showSurface, VGrid_Lib_showAxes, VGrid_Lib_showNormalizedAxes, VGrid_Lib_retrace, GEM_Lib_AppendBuff_IndexN, GEM_Lib_AppendBuff_BitN, GEM_Lib_AppendBuff_N, GEM_Lib_AppendBuff_BitN1, GEM_Lib_AppendBuff_BitN2, GEM_Lib_Rand_N, GEM_Lib_Rand_I, GEM_Lib_Rand_J, GEM_Lib_xN, GEM_Lib_yN, GEM_Lib_tstN, GEM_Lib_trnN, GEM_Lib_levelI, GEM_Lib_levelN, GEM_Lib_searchPntN, GEM_Lib_basisType, GEM_Lib_findMode, GEM_Lib_unknownN, GEM_Lib_K_UN, GEM_Lib_outlierN, GEM_Lib_outlier_errorN, GEM_Lib_outlier_y_error_IndexN, GEM_Lib_fpN, Rand_N, Rand_I, Rand_J, AppendBuff_IndexN, AppendBuff_BitN, AppendBuff_N, AppendBuff_BitN1, AppendBuff_BitN2, Sort_Lib_numberOfArrays, Sort_Lib_arrayLength;
    float signalThickness, predictThickness, profitThickness, VGrid_Lib_BDraw_fontSize, VGrid_Lib_BDraw_boxThickness, VGrid_Lib_resolution, VGrid_Lib_boxLineThickness, VGrid_Lib_axesOpacity, VGrid_Lib_GridLineThickness, VGrid_Lib_opacity, VGrid_Lib_meshVal, VGrid_Lib_orthoSize, VGrid_Lib_maxDist, VGrid_Lib_minResolution, GEM_Lib_tolerance, GEM_Lib_minBasisWidth, GEM_Lib_maxBasisWidth, GEM_Lib_basisStep, GEM_Lib_basisWidth, GEM_Lib_searchRadius, GEM_Lib_searchStep, GEM_Lib_bestScore, GEM_Lib_bestIterationScore, GEM_Lib_outlier_tolerance, GEM_Lib_fp_tolerance;
    float2 profitDisplayRange, VGrid_Lib_GridX, VGrid_Lib_GridY, VGrid_Lib_GridZ, VGrid_Lib_textSize, VGrid_Lib_paletteRange, VGrid_Lib_meshRange;
    float3 mouseRay_origin, mouseRay_direction, VGrid_Lib_axesRangeMin, VGrid_Lib_axesRangeMax, VGrid_Lib_axesRangeMin1, VGrid_Lib_axesRangeMax1, VGrid_Lib_axesRangeMin2, VGrid_Lib_axesRangeMax2, VGrid_Lib_axesColor, VGrid_Lib_slices, VGrid_Lib_sliceRotation;
    float4 VGrid_Lib_BDraw_boxColor;
    uint3 VGrid_Lib_nodeN;
    uint2 VGrid_Lib_viewSize;
    uint4 VGrid_Lib_viewRect, GEM_Lib_Rand_seed4, Rand_seed4;
    Matrix4x4 VGrid_Lib_camToWorld, VGrid_Lib_cameraInvProjection;
  };
  struct MovingAvg { uint movingAvg_prevDayN; float movingAvg_LineThickness; };
  struct DailySale { uint ds_tickerI, ds_buy_date, ds_days_held; float ds_buy_price, ds_sell_price, ds_gain; };
  struct SRule { uint sRule_weighted_avg, sRule_avg_projections; float sRule_slope0, sRule_slope1, sRule_slope2, sRule_bend0, sRule_bend1, sRule_bend2; uint srule_score; float srule_minYearProfit, srule_totalProfit; };
  struct Rule { uint rule_ruleI; uint Rule_weighted_avg, Rule_avg_projections; float Rule_slope0, Rule_slope1, Rule_slope2, Rule_bend0, Rule_bend1, Rule_bend2; uint rule_score; float rule_minYearProfit, rule_totalProfit; };
  struct Trade { uint date; float open, high, low, close, volume; };
  struct VGrid_Lib_BDraw_FontInfo { float2 uvBottomLeft, uvBottomRight, uvTopLeft, uvTopRight; int advance, bearing, minX, minY, maxX, maxY; };
  struct VGrid_Lib_BDraw_TextInfo { float3 p, right, up, p0, p1; float2 size, uvSize; float4 color, backColor; uint justification, textI, quadType, axis; float height; };
  struct VGrid_Lib_TRay { float3 origin, direction; float4 color; float dist; };
  struct Sale { string sale_ticker; uint sale_buy_date; float sale_buy_price; uint sale_days_held; float sale_sell_price, sale_gain, sale_gain_per_day; };
  struct Views_Lib_CamView { string viewName; float3 viewCenter; float viewDist; float2 viewTiltSpin; uint viewProjection; };
  groupshared uint4 GEM_Lib_Rand_grp[1024];
  groupshared uint4 Rand_grp[1024];
  groupshared uint VGrid_Lib_BDraw_AppendBuff_grp[1024];
  groupshared uint VGrid_Lib_BDraw_AppendBuff_grp0[1024];
  groupshared uint GEM_Lib_AppendBuff_grp[1024];
  groupshared uint GEM_Lib_AppendBuff_grp0[1024];
  groupshared uint AppendBuff_grp[1024];
  groupshared uint AppendBuff_grp0[1024];
  RWStructuredBuffer<GQuantrade> gQuantrade;
  RWStructuredBuffer<uint> VGrid_Lib_BDraw_tab_delimeted_text, dates, validTrades, csvText, startYearIs, uYearRanges, yearTradeNs, VGrid_Lib_BDraw_AppendBuff_Bits, VGrid_Lib_BDraw_AppendBuff_Sums, VGrid_Lib_BDraw_AppendBuff_Indexes, VGrid_Lib_BDraw_AppendBuff_Fills1, VGrid_Lib_BDraw_AppendBuff_Fills2, GEM_Lib_AppendBuff_Bits, GEM_Lib_AppendBuff_Sums, GEM_Lib_AppendBuff_Indexes, GEM_Lib_AppendBuff_Fills1, GEM_Lib_AppendBuff_Fills2, GEM_Lib_uints, GEM_Lib_scores, GEM_Lib_maxErrors, GEM_Lib_unknowns, GEM_Lib_K_Us, GEM_Lib_outliers, GEM_Lib_outlier_errors, GEM_Lib_fps, AppendBuff_Bits, AppendBuff_Sums, AppendBuff_Indexes, AppendBuff_Fills1, AppendBuff_Fills2, Sort_Lib_counts, Sort_Lib_sorts;
  RWStructuredBuffer<VGrid_Lib_BDraw_TextInfo> VGrid_Lib_BDraw_textInfos;
  RWStructuredBuffer<VGrid_Lib_BDraw_FontInfo> VGrid_Lib_BDraw_fontInfos;
  RWStructuredBuffer<uint2> VGrid_Lib_depthColors;
  RWStructuredBuffer<Color32> VGrid_Lib_paletteBuffer;
  RWStructuredBuffer<uint4> GEM_Lib_Rand_rs, Rand_rs;
  RWStructuredBuffer<MovingAvg> movingAvgs;
  RWStructuredBuffer<int> avgs, scores, maxDailyTickerScores, maxDailyTickerScoreIs, GEM_Lib_ys, GEM_Lib_Ranges, GEM_Lib_wx;
  RWStructuredBuffer<DailySale> dailySales;
  RWStructuredBuffer<SRule> sRules;
  RWStructuredBuffer<Rule> rules;
  RWStructuredBuffer<float4> OpenHighLowCloses;
  RWStructuredBuffer<Trade> trades;
  RWStructuredBuffer<float2> yearRanges, GEM_Lib_ranges, GEM_Lib_desiredValWeights;
  RWStructuredBuffer<float> VGrid_Lib_Vals, GEM_Lib_tstXs, GEM_Lib_tstYs, GEM_Lib_trnXYs, GEM_Lib_trnCs, GEM_Lib_searchPnts, GEM_Lib_bestInputs, GEM_Lib_tstXs0, GEM_Lib_tstYs0, GEM_Lib_trnXs0, GEM_Lib_trnYs0, GEM_Lib_w_avg_Xs, Sort_Lib_vs;
  [numthreads(numthreads1, 1, 1)] void Find_startTestDayIndex(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.dateN) { } } }
  [numthreads(numthreads2, numthreads2, 1)] void init_uYearRanges(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.tickerN && id.x < g.yearN)
    {
      uint yr_i = id.x, tck_i = id.y, i = yr_i * g.tickerN + tck_i;
      uYearRanges[i * 2] = uint_max; uYearRanges[i * 2 + 1] = 0; yearTradeNs[i] = 0;
    }
    }
  }
  [numthreads(numthreads1, 1, 1)] void findStartYearIs(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.yearN) { startYearIs[id.x] = AppendBuff_Indexes[id.x]; } } }
  [numthreads(numthreads1, 1, 1)] void initAvgs(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.dateN * g.tickerN * g.movingAvgN * 2 * (uint)AvgTypes_N) { avgs[id.x] = 0; } } }
  [numthreads(numthreads1, 1, 1)] void initDailyTickerScores(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.dateN) { maxDailyTickerScores[id.x] = maxDailyTickerScoreIs[id.x] = 0; } } }
  [numthreads(numthreads1, 1, 1)] void initScores(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.dateN * g.tickerN) { scores[id.x] = int_min; } } }
  [numthreads(numthreads1, 1, 1)] void initValidTrades(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.dateN * g.tickerN) { validTrades[id.x] = 1; } } }
  [numthreads(numthreads2, numthreads2, 1)] void Sort_Lib_counts_to_sorts(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.Sort_Lib_arrayLength && id.x < g.Sort_Lib_numberOfArrays)
    {
      uint arrI = id.x, sortI = id.y, j = arrI * g.Sort_Lib_arrayLength, i = j + sortI;
      Sort_Lib_sorts[j + Sort_Lib_counts[i]] = sortI;
    }
    }
  }
  [numthreads(numthreads1, 1, 1)] void Sort_Lib_init_counts(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.Sort_Lib_numberOfArrays * g.Sort_Lib_arrayLength) { Sort_Lib_counts[id.x] = 0; Sort_Lib_sorts[id.x] = 0; } } }
  [numthreads(numthreads1, 1, 1)] void AppendBuff_GetIndexes(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.AppendBuff_BitN) { uint i = id.x, j, sum = i == 0 ? 0 : AppendBuff_Sums[i - 1], b, i32 = i << 5, k; for (k = 0, b = AppendBuff_Bits[i]; b > 0; k++) { j = (uint)findLSB(b); AppendBuff_Indexes[sum + k] = i32 + j; b = SetBitu(b, j, 0); } } } }
  [numthreads(numthreads1, 1, 1)] void AppendBuff_IncSums(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.AppendBuff_BitN) { uint i = id.x; if (i >= numthreads1) AppendBuff_Sums[i] += AppendBuff_Fills1[i / numthreads1 - 1]; if (i == g.AppendBuff_BitN - 1) g.AppendBuff_IndexN = AppendBuff_Sums[i]; } } }
  [numthreads(numthreads1, 1, 1)] void AppendBuff_IncFills1(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.AppendBuff_BitN1) { uint i = id.x; if (i >= numthreads1) AppendBuff_Fills1[i] += AppendBuff_Fills2[i / numthreads1 - 1]; } } }
  [numthreads(numthreads1, 1, 1)] void AppendBuff_GetFills2(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
  {
    uint i = id.x, k = i + 1, j = k * numthreads1 - 1, c = i < g.AppendBuff_BitN2 - 1 ? AppendBuff_Fills1[j] : i < g.AppendBuff_BitN2 ? AppendBuff_Fills1[g.AppendBuff_BitN1 - 1] : 0, s;
    AppendBuff_grp0[grpI] = c; AppendBuff_grp[grpI] = c; GroupMemoryBarrierWithGroupSync();
    for (s = 1; s < numthreads1; s *= 2)
    {
      if (grpI >= s && i < g.AppendBuff_BitN2) AppendBuff_grp[grpI] = AppendBuff_grp0[grpI] + AppendBuff_grp0[grpI - s]; GroupMemoryBarrierWithGroupSync();
      AppendBuff_grp0[grpI] = AppendBuff_grp[grpI]; GroupMemoryBarrierWithGroupSync();
    }
    if (i < g.AppendBuff_BitN2) AppendBuff_Fills2[i] = AppendBuff_grp[grpI];
  }
  [numthreads(numthreads1, 1, 1)] void AppendBuff_GetFills1(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
  {
    uint i = id.x, k = i + 1, j = k * numthreads1 - 1, c = i < g.AppendBuff_BitN1 - 1 ? AppendBuff_Sums[j] : i < g.AppendBuff_BitN1 ? AppendBuff_Sums[g.AppendBuff_BitN - 1] : 0, s;
    AppendBuff_grp0[grpI] = c; AppendBuff_grp[grpI] = c; GroupMemoryBarrierWithGroupSync();
    for (s = 1; s < numthreads1; s *= 2)
    {
      if (grpI >= s && i < g.AppendBuff_BitN1) AppendBuff_grp[grpI] = AppendBuff_grp0[grpI] + AppendBuff_grp0[grpI - s]; GroupMemoryBarrierWithGroupSync();
      AppendBuff_grp0[grpI] = AppendBuff_grp[grpI]; GroupMemoryBarrierWithGroupSync();
    }
    if (i < g.AppendBuff_BitN1) AppendBuff_Fills1[i] = AppendBuff_grp[grpI];
  }
  [numthreads(numthreads1, 1, 1)] void AppendBuff_Get_Bits_Sums(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
  {
    uint i = id.x, c = i < g.AppendBuff_BitN ? countbits(AppendBuff_Bits[i]) : 0, s;
    AppendBuff_grp0[grpI] = c; AppendBuff_grp[grpI] = c; GroupMemoryBarrierWithGroupSync();
    for (s = 1; s < numthreads1; s *= 2)
    {
      if (grpI >= s && i < g.AppendBuff_BitN) AppendBuff_grp[grpI] = AppendBuff_grp0[grpI] + AppendBuff_grp0[grpI - s]; GroupMemoryBarrierWithGroupSync();
      AppendBuff_grp0[grpI] = AppendBuff_grp[grpI]; GroupMemoryBarrierWithGroupSync();
    }
    if (i < g.AppendBuff_BitN) AppendBuff_Sums[i] = AppendBuff_grp[grpI];
  }
  [numthreads(numthreads1, 1, 1)] void Rand_initSeed(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.Rand_N) { uint i = id.x; Rand_rs[i] = i == 0 ? g.Rand_seed4 : u0000; } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_Rand_initSeed(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_Rand_N) { uint i = id.x; GEM_Lib_Rand_rs[i] = i == 0 ? g.GEM_Lib_Rand_seed4 : u0000; } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_AppendBuff_GetIndexes(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_AppendBuff_BitN) { uint i = id.x, j, sum = i == 0 ? 0 : GEM_Lib_AppendBuff_Sums[i - 1], b, i32 = i << 5, k; for (k = 0, b = GEM_Lib_AppendBuff_Bits[i]; b > 0; k++) { j = (uint)findLSB(b); GEM_Lib_AppendBuff_Indexes[sum + k] = i32 + j; b = SetBitu(b, j, 0); } } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_AppendBuff_IncSums(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_AppendBuff_BitN) { uint i = id.x; if (i >= numthreads1) GEM_Lib_AppendBuff_Sums[i] += GEM_Lib_AppendBuff_Fills1[i / numthreads1 - 1]; if (i == g.GEM_Lib_AppendBuff_BitN - 1) g.GEM_Lib_AppendBuff_IndexN = GEM_Lib_AppendBuff_Sums[i]; } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_AppendBuff_IncFills1(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_AppendBuff_BitN1) { uint i = id.x; if (i >= numthreads1) GEM_Lib_AppendBuff_Fills1[i] += GEM_Lib_AppendBuff_Fills2[i / numthreads1 - 1]; } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_AppendBuff_GetFills2(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
  {
    uint i = id.x, k = i + 1, j = k * numthreads1 - 1, c = i < g.GEM_Lib_AppendBuff_BitN2 - 1 ? GEM_Lib_AppendBuff_Fills1[j] : i < g.GEM_Lib_AppendBuff_BitN2 ? GEM_Lib_AppendBuff_Fills1[g.GEM_Lib_AppendBuff_BitN1 - 1] : 0, s;
    GEM_Lib_AppendBuff_grp0[grpI] = c; GEM_Lib_AppendBuff_grp[grpI] = c; GroupMemoryBarrierWithGroupSync();
    for (s = 1; s < numthreads1; s *= 2)
    {
      if (grpI >= s && i < g.GEM_Lib_AppendBuff_BitN2) GEM_Lib_AppendBuff_grp[grpI] = GEM_Lib_AppendBuff_grp0[grpI] + GEM_Lib_AppendBuff_grp0[grpI - s]; GroupMemoryBarrierWithGroupSync();
      GEM_Lib_AppendBuff_grp0[grpI] = GEM_Lib_AppendBuff_grp[grpI]; GroupMemoryBarrierWithGroupSync();
    }
    if (i < g.GEM_Lib_AppendBuff_BitN2) GEM_Lib_AppendBuff_Fills2[i] = GEM_Lib_AppendBuff_grp[grpI];
  }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_AppendBuff_GetFills1(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
  {
    uint i = id.x, k = i + 1, j = k * numthreads1 - 1, c = i < g.GEM_Lib_AppendBuff_BitN1 - 1 ? GEM_Lib_AppendBuff_Sums[j] : i < g.GEM_Lib_AppendBuff_BitN1 ? GEM_Lib_AppendBuff_Sums[g.GEM_Lib_AppendBuff_BitN - 1] : 0, s;
    GEM_Lib_AppendBuff_grp0[grpI] = c; GEM_Lib_AppendBuff_grp[grpI] = c; GroupMemoryBarrierWithGroupSync();
    for (s = 1; s < numthreads1; s *= 2)
    {
      if (grpI >= s && i < g.GEM_Lib_AppendBuff_BitN1) GEM_Lib_AppendBuff_grp[grpI] = GEM_Lib_AppendBuff_grp0[grpI] + GEM_Lib_AppendBuff_grp0[grpI - s]; GroupMemoryBarrierWithGroupSync();
      GEM_Lib_AppendBuff_grp0[grpI] = GEM_Lib_AppendBuff_grp[grpI]; GroupMemoryBarrierWithGroupSync();
    }
    if (i < g.GEM_Lib_AppendBuff_BitN1) GEM_Lib_AppendBuff_Fills1[i] = GEM_Lib_AppendBuff_grp[grpI];
  }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_AppendBuff_Get_Bits_Sums(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
  {
    uint i = id.x, c = i < g.GEM_Lib_AppendBuff_BitN ? countbits(GEM_Lib_AppendBuff_Bits[i]) : 0, s;
    GEM_Lib_AppendBuff_grp0[grpI] = c; GEM_Lib_AppendBuff_grp[grpI] = c; GroupMemoryBarrierWithGroupSync();
    for (s = 1; s < numthreads1; s *= 2)
    {
      if (grpI >= s && i < g.GEM_Lib_AppendBuff_BitN) GEM_Lib_AppendBuff_grp[grpI] = GEM_Lib_AppendBuff_grp0[grpI] + GEM_Lib_AppendBuff_grp0[grpI - s]; GroupMemoryBarrierWithGroupSync();
      GEM_Lib_AppendBuff_grp0[grpI] = GEM_Lib_AppendBuff_grp[grpI]; GroupMemoryBarrierWithGroupSync();
    }
    if (i < g.GEM_Lib_AppendBuff_BitN) GEM_Lib_AppendBuff_Sums[i] = GEM_Lib_AppendBuff_grp[grpI];
  }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_findMaxErrorI(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_tstN) { uint tst_PntI = id.x; if (GEM_Lib_maxErrors[tst_PntI] == GEM_Lib_uints[GEM_Lib_UInts_maxError]) GEM_Lib_uints[GEM_Lib_UInts_maxErrorI] = tst_PntI; } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_findMaxError(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_tstN) { uint tst_PntI = id.x; InterlockedMax(GEM_Lib_uints, GEM_Lib_UInts_maxError, GEM_Lib_maxErrors[tst_PntI]); } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_initMaxError(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_tstN) { uint tst_PntI = id.x; GEM_Lib_maxErrors[tst_PntI] = 0; if (tst_PntI == 0) GEM_Lib_uints[GEM_Lib_UInts_maxError] = 0; } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_update_w_avg_Xs(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_xN) { uint xI = id.x; GEM_Lib_w_avg_Xs[xI] = (GEM_Lib_wx[xI] / 1e6f) + GEM_Lib_bestInputs[xI]; } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_update_best_Score(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < 1) { g.GEM_Lib_bestIterationScore = GEM_Lib_scores[GEM_Lib_uints[GEM_Lib_UInts_mxScoreI]] / 1e6f; } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_init_w(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_xN + 1) { uint xI = id.x; if (xI < g.GEM_Lib_xN) GEM_Lib_wx[xI] = 0; else GEM_Lib_uints[GEM_Lib_UInts_sum_w] = 0; } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_calc_sum_w(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.GEM_Lib_searchPntN)
    {
      uint searchI = id.x;
      uint score = GEM_Lib_scores[searchI], mnScore = GEM_Lib_scores[GEM_Lib_uints[GEM_Lib_UInts_mnScoreI]], mxScore = GEM_Lib_scores[GEM_Lib_uints[GEM_Lib_UInts_mxScoreI]], avgScore = mxScore / 2 + mnScore / 2;
      if (score > avgScore) InterlockedAdd(GEM_Lib_uints, GEM_Lib_UInts_sum_w, score - avgScore);
    }
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_find_mn_mx_ScoreIs(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < 2 && id.x < g.GEM_Lib_searchPntN)
    {
      uint searchI = id.x, mI = id.y;
      if (mI == 0) { if (GEM_Lib_scores[searchI] == GEM_Lib_uints[GEM_Lib_UInts_mxScore]) GEM_Lib_uints[GEM_Lib_UInts_mxScoreI] = searchI; }
      else { if (GEM_Lib_scores[searchI] == GEM_Lib_uints[GEM_Lib_UInts_mnScore]) GEM_Lib_uints[GEM_Lib_UInts_mnScoreI] = searchI; }
    }
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_find_mn_mx_Scores(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < 2 && id.x < g.GEM_Lib_searchPntN)
    {
      uint searchI = id.x, mI = id.y;
      if (mI == 0) InterlockedMax(GEM_Lib_uints, GEM_Lib_UInts_mxScore, GEM_Lib_scores[searchI]); else InterlockedMin(GEM_Lib_uints, GEM_Lib_UInts_mnScore, GEM_Lib_scores[searchI]);
    }
    }
  }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_inv_Scores(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.GEM_Lib_searchPntN)
    {
      uint searchI = id.x, mI = id.y;
      uint Score = roundu(rcp(1e-6f * (GEM_Lib_scores[searchI] + 1)));
      GEM_Lib_scores[searchI] = Score;
      InterlockedMax(GEM_Lib_uints, GEM_Lib_UInts_mxScore, Score);
      InterlockedMin(GEM_Lib_uints, GEM_Lib_UInts_mnScore, Score);
    }
    }
  }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_init_search(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.GEM_Lib_searchPntN + 3)
    {
      uint i = id.x;
      if (i < g.GEM_Lib_searchPntN) GEM_Lib_scores[i] = 0;
      else
      {
        i -= g.GEM_Lib_searchPntN;
        if (i == 0) GEM_Lib_uints[GEM_Lib_UInts_mxScore] = 0; else if (i == 1) GEM_Lib_uints[GEM_Lib_UInts_mnScore] = uint_max; else GEM_Lib_uints[GEM_Lib_UInts_best_score] = 0;
      }
    }
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_init_search_inputs(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < 2 && id.x < g.GEM_Lib_xN)
    {
      uint xI = id.x, j = id.y;
      float2 dw = GEM_Lib_desiredValWeights[xI];
      if (j == 0) GEM_Lib_bestInputs[xI] = dw.y >= 0.99f ? dw.x : 0.5f;
      else GEM_Lib_w_avg_Xs[xI] = dw.x;
    }
    }
  }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_initMissingEntries(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < 2) { GEM_Lib_uints[id.x] = 0; } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_Copy_Ranges_To_ranges(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_xN + g.GEM_Lib_yN) { uint i = id.x; GEM_Lib_ranges[i] = float2(GEM_Lib_Ranges[i * 2], GEM_Lib_Ranges[i * 2 + 1]) / 100000.0f; } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_Init_Ranges(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_xN + g.GEM_Lib_yN) { uint i = id.x; GEM_Lib_Ranges[i * 2] = int_max; GEM_Lib_Ranges[i * 2 + 1] = int_min; } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_assign_outliers(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_outlierN) { uint i = id.x; GEM_Lib_outliers[i] = GEM_Lib_AppendBuff_Indexes[i]; } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_assign_K_Us(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_K_UN) { uint i = id.x; GEM_Lib_K_Us[i] = GEM_Lib_AppendBuff_Indexes[i]; } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_assign_unknowns(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_unknownN) { uint i = id.x; GEM_Lib_unknowns[i] = GEM_Lib_AppendBuff_Indexes[i]; } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_find_max_fpI(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_tstN) { uint i = id.x; if (GEM_Lib_uints[GEM_Lib_UInts_maxOutlier] == GEM_Lib_outlier_errors[i]) GEM_Lib_uints[GEM_Lib_UInts_maxOutlierI] = i; } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_calc_max_fp(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_tstN) { uint i = id.x; InterlockedMax(GEM_Lib_uints, GEM_Lib_UInts_maxOutlier, GEM_Lib_outlier_errors[i]); } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_init_max_fp(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < 1) { GEM_Lib_uints[GEM_Lib_UInts_maxOutlier] = 0; GEM_Lib_uints[GEM_Lib_UInts_maxOutlierI] = 0; } } }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_init_fp_errors(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_tstN) { GEM_Lib_outlier_errors[id.x] = 0; } } }
  [numthreads(numthreads1, 1, 1)] void VGrid_Lib_BDraw_AppendBuff_GetIndexes(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.VGrid_Lib_BDraw_AppendBuff_BitN) { uint i = id.x, j, sum = i == 0 ? 0 : VGrid_Lib_BDraw_AppendBuff_Sums[i - 1], b, i32 = i << 5, k; for (k = 0, b = VGrid_Lib_BDraw_AppendBuff_Bits[i]; b > 0; k++) { j = (uint)findLSB(b); VGrid_Lib_BDraw_AppendBuff_Indexes[sum + k] = i32 + j; b = SetBitu(b, j, 0); } } } }
  [numthreads(numthreads1, 1, 1)] void VGrid_Lib_BDraw_AppendBuff_IncSums(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.VGrid_Lib_BDraw_AppendBuff_BitN) { uint i = id.x; if (i >= numthreads1) VGrid_Lib_BDraw_AppendBuff_Sums[i] += VGrid_Lib_BDraw_AppendBuff_Fills1[i / numthreads1 - 1]; if (i == g.VGrid_Lib_BDraw_AppendBuff_BitN - 1) g.VGrid_Lib_BDraw_AppendBuff_IndexN = VGrid_Lib_BDraw_AppendBuff_Sums[i]; } } }
  [numthreads(numthreads1, 1, 1)] void VGrid_Lib_BDraw_AppendBuff_IncFills1(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.VGrid_Lib_BDraw_AppendBuff_BitN1) { uint i = id.x; if (i >= numthreads1) VGrid_Lib_BDraw_AppendBuff_Fills1[i] += VGrid_Lib_BDraw_AppendBuff_Fills2[i / numthreads1 - 1]; } } }
  [numthreads(numthreads1, 1, 1)] void VGrid_Lib_BDraw_AppendBuff_GetFills2(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
  {
    uint i = id.x, k = i + 1, j = k * numthreads1 - 1, c = i < g.VGrid_Lib_BDraw_AppendBuff_BitN2 - 1 ? VGrid_Lib_BDraw_AppendBuff_Fills1[j] : i < g.VGrid_Lib_BDraw_AppendBuff_BitN2 ? VGrid_Lib_BDraw_AppendBuff_Fills1[g.VGrid_Lib_BDraw_AppendBuff_BitN1 - 1] : 0, s;
    VGrid_Lib_BDraw_AppendBuff_grp0[grpI] = c; VGrid_Lib_BDraw_AppendBuff_grp[grpI] = c; GroupMemoryBarrierWithGroupSync();
    for (s = 1; s < numthreads1; s *= 2)
    {
      if (grpI >= s && i < g.VGrid_Lib_BDraw_AppendBuff_BitN2) VGrid_Lib_BDraw_AppendBuff_grp[grpI] = VGrid_Lib_BDraw_AppendBuff_grp0[grpI] + VGrid_Lib_BDraw_AppendBuff_grp0[grpI - s]; GroupMemoryBarrierWithGroupSync();
      VGrid_Lib_BDraw_AppendBuff_grp0[grpI] = VGrid_Lib_BDraw_AppendBuff_grp[grpI]; GroupMemoryBarrierWithGroupSync();
    }
    if (i < g.VGrid_Lib_BDraw_AppendBuff_BitN2) VGrid_Lib_BDraw_AppendBuff_Fills2[i] = VGrid_Lib_BDraw_AppendBuff_grp[grpI];
  }
  [numthreads(numthreads1, 1, 1)] void VGrid_Lib_BDraw_AppendBuff_GetFills1(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
  {
    uint i = id.x, k = i + 1, j = k * numthreads1 - 1, c = i < g.VGrid_Lib_BDraw_AppendBuff_BitN1 - 1 ? VGrid_Lib_BDraw_AppendBuff_Sums[j] : i < g.VGrid_Lib_BDraw_AppendBuff_BitN1 ? VGrid_Lib_BDraw_AppendBuff_Sums[g.VGrid_Lib_BDraw_AppendBuff_BitN - 1] : 0, s;
    VGrid_Lib_BDraw_AppendBuff_grp0[grpI] = c; VGrid_Lib_BDraw_AppendBuff_grp[grpI] = c; GroupMemoryBarrierWithGroupSync();
    for (s = 1; s < numthreads1; s *= 2)
    {
      if (grpI >= s && i < g.VGrid_Lib_BDraw_AppendBuff_BitN1) VGrid_Lib_BDraw_AppendBuff_grp[grpI] = VGrid_Lib_BDraw_AppendBuff_grp0[grpI] + VGrid_Lib_BDraw_AppendBuff_grp0[grpI - s]; GroupMemoryBarrierWithGroupSync();
      VGrid_Lib_BDraw_AppendBuff_grp0[grpI] = VGrid_Lib_BDraw_AppendBuff_grp[grpI]; GroupMemoryBarrierWithGroupSync();
    }
    if (i < g.VGrid_Lib_BDraw_AppendBuff_BitN1) VGrid_Lib_BDraw_AppendBuff_Fills1[i] = VGrid_Lib_BDraw_AppendBuff_grp[grpI];
  }
  [numthreads(numthreads1, 1, 1)] void VGrid_Lib_BDraw_AppendBuff_Get_Bits_Sums(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
  {
    uint i = id.x, c = i < g.VGrid_Lib_BDraw_AppendBuff_BitN ? countbits(VGrid_Lib_BDraw_AppendBuff_Bits[i]) : 0, s;
    VGrid_Lib_BDraw_AppendBuff_grp0[grpI] = c; VGrid_Lib_BDraw_AppendBuff_grp[grpI] = c; GroupMemoryBarrierWithGroupSync();
    for (s = 1; s < numthreads1; s *= 2)
    {
      if (grpI >= s && i < g.VGrid_Lib_BDraw_AppendBuff_BitN) VGrid_Lib_BDraw_AppendBuff_grp[grpI] = VGrid_Lib_BDraw_AppendBuff_grp0[grpI] + VGrid_Lib_BDraw_AppendBuff_grp0[grpI - s]; GroupMemoryBarrierWithGroupSync();
      VGrid_Lib_BDraw_AppendBuff_grp0[grpI] = VGrid_Lib_BDraw_AppendBuff_grp[grpI]; GroupMemoryBarrierWithGroupSync();
    }
    if (i < g.VGrid_Lib_BDraw_AppendBuff_BitN) VGrid_Lib_BDraw_AppendBuff_Sums[i] = VGrid_Lib_BDraw_AppendBuff_grp[grpI];
  }
  [numthreads(numthreads1, 1, 1)] void Rand_grp_fill_1K(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex) { null; }
  [numthreads(numthreads1, 1, 1)] void Rand_grp_init_1K(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex) { null; }
   
  [numthreads(numthreads1, 1, 1)] void Rand_grp_init_1M(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex) { null; }
   
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_Rand_grp_fill_1K(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex) { null; }
   
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_Rand_grp_init_1K(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex) { null; }
   
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_Rand_grp_init_1M(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex) { null; }
   
  [numthreads(numthreads2, numthreads2, 1)] void setAvgs(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.tickerN && id.x < g.dateN) { }
     
    }
  }
  uint2 Get_tab_indexes(uint tabI) { return uint2(tabI == 0 ? 0 : AppendBuff_Indexes[tabI - 1] + 1, tabI == g.ticker_csv_item_N ? g.ticker_csv_uint_N * 4 : AppendBuff_Indexes[tabI]); }
  float i2f() { return 1e4f; }
  [numthreads(numthreads2, numthreads2, 1)] void calc_yearRanges(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.tickerN && id.x < g.yearN)
    {
      uint yr_i = id.x, tck_i = id.y, i = yr_i * g.tickerN + tck_i;
      yearRanges[i] = float2(uYearRanges[i * 2], uYearRanges[i * 2 + 1]) / i2f();
    }
    }
  }
  uint yr(uint _date) { return _date / 10000; }
  uint OHLC_N() { return Is(g.includeOpen) + Is(g.includeClose) + Is(g.includeHigh) + Is(g.includeLow); }
  uint csvUInt(uint i) { return ToUInt(csvText, Get_tab_indexes(i)); }
  [numthreads(numthreads1, 1, 1)] void csv_to_dates(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.dateN) { uint i = id.x, j = (i + 1) * (g.tickerN * OHLC_N() + 1); dates[i] = csvUInt(j); } } }
  float csvFloat(uint i) { return ToFloat(csvText, Get_tab_indexes(i)); }
  uint AvgI(uint _dateI, uint _tckI, uint _avgI, uint t) { return ((t * g.movingAvgN + _avgI) * g.tickerN + _tckI) * g.dateN + _dateI; }
  uint ScoreI(uint _dateI, uint _tckI) { return _tckI * g.dateN + _dateI; }
  float Score(uint _dateI, uint _tckI) { return scores[ScoreI(_dateI, _tckI)] / 1e6f; }
  [numthreads(numthreads2, numthreads2, 1)] void findDailyTickerScoreIs(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.tickerN && id.x < g.dateN)
    {
      uint _dateI = id.x, _tckI = id.y;
      if (roundi(Score(_dateI, _tckI) * 1e6f) == maxDailyTickerScores[_dateI])
        maxDailyTickerScoreIs[_dateI] = (int)_tckI;
    }
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void findDailyTickerScores(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.tickerN && id.x < g.dateN)
    {
      uint _dateI = id.x, _tckI = id.y;
      InterlockedMax(maxDailyTickerScores, _dateI, roundi(Score(_dateI, _tckI) * 1e6f));
    }
    }
  }
  bool Sort_Lib_compare(uint2 u) { return Sort_Lib_vs[u.x] > Sort_Lib_vs[u.y]; }
  [numthreads(numthreads2, numthreads2, 1)] void Sort_Lib_add_counts_triangle(uint3 id : SV_DispatchThreadID) { unchecked { if (id.y < g.Sort_Lib_arrayLength * (g.Sort_Lib_arrayLength - 1) / 2 && id.x < g.Sort_Lib_numberOfArrays) { uint arrI = id.x, k = id.y, j = arrI * g.Sort_Lib_arrayLength; uint2 u = upperTriangularIndex(k, g.Sort_Lib_arrayLength) + u11 * j; InterlockedAdd(Sort_Lib_counts, Sort_Lib_compare(u) ? u.x : u.y, 1); } } }
  uint GEM_Lib_tstXI(uint _tst_PntI, uint xI) { return _tst_PntI * g.GEM_Lib_xN + xI; }
  void GEM_Lib_tstX(uint _tstI, uint xI, float v) { GEM_Lib_tstXs[GEM_Lib_tstXI(_tstI, xI)] = v; }
  uint GEM_Lib_tstYI(uint _tst_PntI, uint yI) { return _tst_PntI * g.GEM_Lib_yN + yI; }
  [numthreads(numthreads3, numthreads3, numthreads3)] void GEM_Lib_zero_output_ys(uint3 id : SV_DispatchThreadID) { unchecked { if (id.z < 2 && id.y < g.GEM_Lib_yN && id.x < g.GEM_Lib_tstN) { uint _tst_PntI = id.x, yI = id.y, outI = GEM_Lib_tstYI(_tst_PntI, yI) * 2 + id.z; GEM_Lib_ys[outI] = 0; } } }
  void GEM_Lib_tstY(uint _tstI, uint yI, float v) { GEM_Lib_tstYs[GEM_Lib_tstYI(_tstI, yI)] = v; }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_remove_maxError_tst_Pnt(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.GEM_Lib_xN + g.GEM_Lib_yN && id.x < g.GEM_Lib_tstN)
    {
      uint tst_PntI = id.x, i = id.y, tst_PntJ = tst_PntI + Is(tst_PntI >= GEM_Lib_uints[GEM_Lib_UInts_maxErrorI]);
      if (i < g.GEM_Lib_xN) GEM_Lib_tstX(tst_PntI, i, GEM_Lib_tstXs0[GEM_Lib_tstXI(tst_PntJ, i)]); else GEM_Lib_tstY(tst_PntI, i - g.GEM_Lib_xN, GEM_Lib_tstYs0[GEM_Lib_tstYI(tst_PntJ, i - g.GEM_Lib_xN)]);
    }
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_zero_outputs(uint3 id : SV_DispatchThreadID) { unchecked { if (id.y < g.GEM_Lib_yN && id.x < g.GEM_Lib_tstN) { uint _tst_PntI = id.x, yI = id.y; GEM_Lib_tstY(_tst_PntI, yI, 0); } } }
  float GEM_Lib_tstX_01(uint _tstI, uint xI) { return GEM_Lib_tstXs[GEM_Lib_tstXI(_tstI, xI)]; }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_normalize_inputs(uint3 id : SV_DispatchThreadID) { unchecked { if (id.y < g.GEM_Lib_xN && id.x < g.GEM_Lib_tstN) { uint _tst_PntI = id.x, xI = id.y; GEM_Lib_tstX(_tst_PntI, xI, lerp1(GEM_Lib_ranges[xI], GEM_Lib_tstX_01(_tst_PntI, xI))); } } }
  float GEM_Lib_tstY(uint _tstI, uint yI) { return GEM_Lib_tstYs[GEM_Lib_tstYI(_tstI, yI)]; }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_copy_tst_Pnts(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.GEM_Lib_xN + g.GEM_Lib_yN && id.x < g.GEM_Lib_tstN)
    {
      uint tst_PntI = id.x, i = id.y;
      if (i < g.GEM_Lib_xN) GEM_Lib_tstXs0[GEM_Lib_tstXI(tst_PntI, i)] = GEM_Lib_tstX_01(tst_PntI, i); else GEM_Lib_tstYs0[GEM_Lib_tstYI(tst_PntI, i - g.GEM_Lib_xN)] = GEM_Lib_tstY(tst_PntI, i - g.GEM_Lib_xN);
    }
    }
  }
  uint GEM_Lib_trnXI(uint pntI, uint xI) { return pntI * g.GEM_Lib_xN + xI; }
  void GEM_Lib_trnX(uint pntI, uint xI, float v) { GEM_Lib_trnXYs[GEM_Lib_trnXI(pntI, xI)] = v; }
  uint GEM_Lib_trnCI(uint _levelI, uint pntI, uint yI) { return (_levelI * g.GEM_Lib_trnN + pntI) * g.GEM_Lib_yN + yI; }
  void GEM_Lib_trnC(uint _levelI, uint pntI, uint yI, float v) { GEM_Lib_trnCs[GEM_Lib_trnCI(_levelI, pntI, yI)] = v; }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_move_tst_Pnt_to_pnt(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.GEM_Lib_xN + g.GEM_Lib_yN && id.x < g.GEM_Lib_trnN)
    {
      uint pntI = id.x, i = id.y;
      if (i < g.GEM_Lib_xN) GEM_Lib_trnX(pntI, i, pntI < g.GEM_Lib_trnN - 1 ? GEM_Lib_trnXs0[GEM_Lib_trnXI(pntI, i)] : GEM_Lib_tstXs0[GEM_Lib_trnXI(GEM_Lib_uints[GEM_Lib_UInts_maxErrorI], i)]);
      else GEM_Lib_trnC(0, pntI, i - g.GEM_Lib_xN, pntI < g.GEM_Lib_trnN - 1 ? GEM_Lib_trnYs0[GEM_Lib_trnCI(0, pntI, i - g.GEM_Lib_xN)] : GEM_Lib_tstYs0[GEM_Lib_trnCI(0, GEM_Lib_uints[GEM_Lib_UInts_maxErrorI], i - g.GEM_Lib_xN)]);
    }
    }
  }
  float GEM_Lib_trnX(uint pntI, uint xI) { return GEM_Lib_trnXYs[GEM_Lib_trnXI(pntI, xI)]; }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_copy_pntXs_inputs(uint3 id : SV_DispatchThreadID) { unchecked { if (id.y < g.GEM_Lib_xN && id.x < g.GEM_Lib_trnN) { uint pntI = id.x, xI = id.y; GEM_Lib_tstX(pntI, xI, GEM_Lib_trnX(pntI, xI)); } } }
  float GEM_Lib_trnC(uint _levelI, uint pntI, uint yI) { return GEM_Lib_trnCs[GEM_Lib_trnCI(_levelI, pntI, yI)]; }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_copy_pnts(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.GEM_Lib_xN + g.GEM_Lib_yN && id.x < g.GEM_Lib_trnN)
    {
      uint pntI = id.x, i = id.y;
      if (i < g.GEM_Lib_xN) GEM_Lib_trnXs0[GEM_Lib_trnXI(pntI, i)] = GEM_Lib_trnX(pntI, i); else GEM_Lib_trnYs0[GEM_Lib_trnCI(0, pntI, i - g.GEM_Lib_xN)] = GEM_Lib_trnC(0, pntI, i - g.GEM_Lib_xN);
    }
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_copy_pnts_to_tst_Pnts(uint3 id : SV_DispatchThreadID) { unchecked { if (id.y < g.GEM_Lib_xN + g.GEM_Lib_yN && id.x < g.GEM_Lib_trnN) { uint pntI = id.x, i = id.y; if (i < g.GEM_Lib_xN) GEM_Lib_tstX(pntI, i, GEM_Lib_trnX(pntI, i)); else GEM_Lib_tstY(pntI, i - g.GEM_Lib_xN, GEM_Lib_trnC(0, pntI, i - g.GEM_Lib_xN)); } } }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_detectMissingEntries(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.GEM_Lib_xN + g.GEM_Lib_yN && id.x < g.GEM_Lib_trnN)
    {
      uint pntI = id.x, i = id.y;
      if (i < g.GEM_Lib_xN) { if (IsNegInf(GEM_Lib_trnX(pntI, i))) InterlockedOr(GEM_Lib_uints, GEM_Lib_UInts_missingInputs, 1); }
      else { if (IsNegInf(GEM_Lib_trnC(0, pntI, i - g.GEM_Lib_xN))) InterlockedOr(GEM_Lib_uints, GEM_Lib_UInts_missingOutputs, 1); }
    }
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_copy_outputs_pntYs(uint3 id : SV_DispatchThreadID) { unchecked { if (id.y < g.GEM_Lib_yN && id.x < g.GEM_Lib_trnN) { uint pntI = id.x, yI = id.y; if (g.GEM_Lib_levelI + 1 < g.GEM_Lib_levelN) GEM_Lib_trnC(g.GEM_Lib_levelI + 1, pntI, yI, GEM_Lib_trnC(g.GEM_Lib_levelI, pntI, yI) - GEM_Lib_tstY(pntI, yI)); } } }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_copy_pntYs_outputs(uint3 id : SV_DispatchThreadID) { unchecked { if (id.y < g.GEM_Lib_yN && id.x < g.GEM_Lib_trnN) { uint pntI = id.x, yI = id.y; GEM_Lib_tstY(pntI, yI, GEM_Lib_trnC(g.GEM_Lib_levelI, pntI, yI)); } } }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_normalize_trn_Points(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.GEM_Lib_xN + g.GEM_Lib_yN && id.x < g.GEM_Lib_trnN)
    {
      uint pntI = id.x, xI = id.y, yI = xI - g.GEM_Lib_xN;
      if (xI < g.GEM_Lib_xN) { float v = GEM_Lib_trnX(pntI, xI); if (IsNotNegInf(v)) GEM_Lib_trnX(pntI, xI, lerp1(GEM_Lib_ranges[xI], v)); }
      else { float v = GEM_Lib_trnC(0, pntI, yI); if (IsNotNegInf(v)) GEM_Lib_trnC(0, pntI, yI, lerp1(GEM_Lib_ranges[yI + g.GEM_Lib_xN], v)); }
    }
    }
  }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_Get_ranges(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.GEM_Lib_xN + g.GEM_Lib_yN)
    {
      float2 r = initRange;
      if (id.x < g.GEM_Lib_xN) { uint xI = id.x; for (uint pntI = 0; pntI < g.GEM_Lib_trnN; pntI++) { float v = GEM_Lib_trnX(pntI, xI); if (IsNotNegInf(v)) r = SetRange(r, v); } }
      else { uint yI = id.x - g.GEM_Lib_xN; for (uint pntI = 0; pntI < g.GEM_Lib_trnN; pntI++) { float v = GEM_Lib_trnC(0, pntI, yI); if (IsNotNegInf(v)) r = SetRange(r, v); } }
      GEM_Lib_ranges[id.x] = r;
    }
    }
  }
  uint GEM_Lib_f2u(float f) { return roundu(f * 1e6f); }
  uint GEM_Lib_searchPntI(uint pntI, uint xI) { return pntI * g.GEM_Lib_xN + xI; }
  float GEM_Lib_searchPntX(uint pntI, uint xI) { return GEM_Lib_searchPnts[GEM_Lib_searchPntI(pntI, xI)]; }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_update_best_x(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_xN) { uint xI = id.x; GEM_Lib_bestInputs[xI] = GEM_Lib_searchPntX(GEM_Lib_uints[GEM_Lib_UInts_mxScoreI], xI); } } }
  void GEM_Lib_searchPntX(uint pntI, uint xI, float v) { GEM_Lib_searchPnts[GEM_Lib_searchPntI(pntI, xI)] = v; }
  float GEM_Lib_tstY_v(uint _tstI, uint yI) { return lerp(GEM_Lib_ranges[g.GEM_Lib_xN + yI], GEM_Lib_tstY(_tstI, yI)); }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_unNormalize_outputs(uint3 id : SV_DispatchThreadID) { unchecked { if (id.y < g.GEM_Lib_yN && id.x < g.GEM_Lib_tstN) { uint _tst_PntI = id.x, yI = id.y; GEM_Lib_tstY(_tst_PntI, yI, GEM_Lib_tstY_v(_tst_PntI, yI)); } } }
  float GEM_Lib_Basis(float dst, float width)
  {
    float v = dst * rcp(width), h = 0.1f, d = 1 - h;
    switch ((uint)g.GEM_Lib_basisType)
    {
      case GEM_Lib_BasisType_Pow2: v = max(0.001f, pow2(-sqr(v))); break;
      case GEM_Lib_BasisType_Exp: v = max(0.001f, exp(-sqr(v))); break;
      case GEM_Lib_BasisType_Cubic: v = max(h, d - v * (d - 0.5f)); v = v * v * (3 - 2 * v); break;
      case GEM_Lib_BasisType_Linear: v = max(h, d - v * (d - 0.5f)); break;
    }
    return v;
  }
  [numthreads(numthreads3, numthreads3, numthreads3)] void GEM_Lib_calc_output_ys(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.z < g.GEM_Lib_yN && id.y < g.GEM_Lib_trnN && id.x < g.GEM_Lib_tstN)
    {
      uint _tst_PntI = id.x, pntI = id.y, yI = id.z, xI;
      float dst2;
      for (dst2 = 0, xI = 0; xI < g.GEM_Lib_xN; xI++) dst2 += sqr(GEM_Lib_trnX(pntI, xI) - GEM_Lib_tstX_01(_tst_PntI, xI));
      float weight = GEM_Lib_Basis(sqrt(dst2), g.GEM_Lib_basisWidth), y = GEM_Lib_trnC(g.GEM_Lib_levelI, pntI, yI);
      float2 valWeight = float2(y * weight, weight);
      int2 V = roundi(valWeight * 1e6f);
      uint outI = GEM_Lib_tstYI(_tst_PntI, yI) * 2;
      InterlockedAdd(GEM_Lib_ys, outI, V.x);
      InterlockedAdd(GEM_Lib_ys, outI + 1, V.y);
    }
    }
  }
  float GEM_Lib_calc_dist2_trn_trn(uint i1, uint i2) { float d = 0; for (uint xI = 0; xI < g.GEM_Lib_xN; xI++) d += sqr(GEM_Lib_trnX(i1, xI) - GEM_Lib_trnX(i2, xI)); return d; }
  float GEM_Lib_Calc_Output_v(float yw, float w) { bool lev0 = g.GEM_Lib_levelI == 0; return lev0 && w == 0 ? 0 : yw * rcp(lev0 ? w : max(w, 1)); }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_calc_pntHs(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.GEM_Lib_yN && id.x < g.GEM_Lib_trnN)
    {
      uint pntI0 = id.x, yI = id.y;
      float y0 = GEM_Lib_trnC(g.GEM_Lib_levelI, pntI0, yI), y1, dst2, weight, y;
      float2 valWeight = f00;
      for (uint pntI = 0; pntI < g.GEM_Lib_trnN; pntI++)
        if (pntI != pntI0)
        {
          dst2 = GEM_Lib_calc_dist2_trn_trn(pntI0, pntI);
          weight = GEM_Lib_Basis(sqrt(dst2), g.GEM_Lib_basisWidth); y = GEM_Lib_trnC(g.GEM_Lib_levelI, pntI, yI);
          valWeight += float2(y * weight, weight);
        }
      weight = GEM_Lib_Basis(0, g.GEM_Lib_basisWidth); y = GEM_Lib_trnC(g.GEM_Lib_levelI, pntI0, yI);
      valWeight += float2(y * weight, weight);
      y1 = GEM_Lib_Calc_Output_v(valWeight.x, valWeight.y);
      float GEM_Lib_error = y0 - y1;
      GEM_Lib_trnC(g.GEM_Lib_levelI + 1, pntI0, yI, GEM_Lib_error);
    }
    }
  }
  float GEM_Lib_Calc_Output_v(uint outputI) { return GEM_Lib_Calc_Output_v(GEM_Lib_ys[outputI * 2] * 1e-6f, GEM_Lib_ys[outputI * 2 + 1] * 1e-6f); }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_calc_output_sums(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.GEM_Lib_yN && id.x < g.GEM_Lib_tstN)
    {
      uint _tst_PntI = id.x, yI = id.y, outputI = GEM_Lib_tstYI(_tst_PntI, yI);
      float v = GEM_Lib_Calc_Output_v(outputI);
      if (g.GEM_Lib_levelI > 0) v += GEM_Lib_tstY(_tst_PntI, yI);
      GEM_Lib_tstY(_tst_PntI, yI, v);
    }
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_calc_outputs_01(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.GEM_Lib_yN && id.x < g.GEM_Lib_tstN)
    {
      uint _tst_PntI = id.x, yI = id.y, outputI = GEM_Lib_tstYI(_tst_PntI, yI);
      float v = GEM_Lib_Calc_Output_v(outputI);
      GEM_Lib_tstY(_tst_PntI, yI, v);
    }
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_calc_outputs_v(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.GEM_Lib_yN && id.x < g.GEM_Lib_tstN)
    {
      uint _tst_PntI = id.x, yI = id.y, outputI = GEM_Lib_tstYI(_tst_PntI, yI);
      float v = GEM_Lib_Calc_Output_v(outputI);
      v = lerp(GEM_Lib_ranges[g.GEM_Lib_xN + yI], v);
      GEM_Lib_tstY(_tst_PntI, yI, v);
    }
    }
  }
  uint GEM_Lib_trnYI(uint pntI, uint yI) { return g.GEM_Lib_trnN * g.GEM_Lib_xN + pntI * g.GEM_Lib_yN + yI; }
  float GEM_Lib_Get_tstInput(uint tstI, uint xI) { return tstI / (g.GEM_Lib_tstN - 1.0f); }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_assign_tst_Inputs(uint3 id : SV_DispatchThreadID) { unchecked { if (id.y < g.GEM_Lib_xN && id.x < g.GEM_Lib_tstN) { uint _tstI = id.x, xI = id.y; GEM_Lib_tstX(_tstI, xI, GEM_Lib_Get_tstInput(_tstI, xI)); } } }
  float GEM_Lib_trnY(uint pntI, uint yI) { return GEM_Lib_trnXYs[GEM_Lib_trnYI(pntI, yI)]; }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_calc_fp_errors(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.GEM_Lib_yN && id.x < g.GEM_Lib_tstN)
    {
      uint i = id.x, yI = id.y;
      float trn_y = GEM_Lib_trnY(i, yI), tst_y = GEM_Lib_tstY(i, yI), e = abs(trn_y - tst_y) / g.GEM_Lib_yN;
      uint E = roundu(e * 1e6f);
      InterlockedAdd(GEM_Lib_outlier_errors, i, E);
    }
    }
  }
  VGrid_Lib_BDraw_TextInfo VGrid_Lib_BDraw_textInfo(uint i) { return VGrid_Lib_BDraw_textInfos[i]; }
  void VGrid_Lib_BDraw_textInfo(uint i, VGrid_Lib_BDraw_TextInfo t) { VGrid_Lib_BDraw_textInfos[i] = t; }
  [numthreads(numthreads1, 1, 1)] void VGrid_Lib_BDraw_setDefaultTextInfo(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.VGrid_Lib_BDraw_textN)
    {
      uint i = id.x;
      if (i > 0)
      {
        VGrid_Lib_BDraw_TextInfo t = VGrid_Lib_BDraw_textInfo(0), ti = VGrid_Lib_BDraw_textInfo(i);
        ti.color = t.color; ti.backColor = t.backColor; ti.p = t.p; ti.p0 = t.p0; ti.p1 = t.p1; ti.height = t.height;
        ti.quadType = (uint)t.quadType; ti.axis = t.axis; ti.right = t.right; ti.up = t.up; ti.justification = t.justification;
        VGrid_Lib_BDraw_textInfo(i, ti);
      }
    }
    }
  }
  uint2 VGrid_Lib_BDraw_Get_text_indexes(uint textI) { return uint2(textI == 0 ? 0 : VGrid_Lib_BDraw_AppendBuff_Indexes[textI - 1] + 1, textI < g.VGrid_Lib_BDraw_AppendBuff_IndexN ? VGrid_Lib_BDraw_AppendBuff_Indexes[textI] : g.VGrid_Lib_BDraw_textCharN); }
  uint VGrid_Lib_BDraw_Byte(uint i) { return TextByte(VGrid_Lib_BDraw_tab_delimeted_text, i); }
  [numthreads(numthreads1, 1, 1)] void VGrid_Lib_BDraw_getTextInfo(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.VGrid_Lib_BDraw_textN)
    {
      uint i = id.x;
      VGrid_Lib_BDraw_TextInfo ti = VGrid_Lib_BDraw_textInfo(i);
      ti.textI = i;
      ti.uvSize = f01;
      uint2 textIs = VGrid_Lib_BDraw_Get_text_indexes(i);
      float2 t = ti.uvSize;
      for (uint j = textIs.x; j < textIs.y; j++) { uint byteI = VGrid_Lib_BDraw_Byte(j); if (byteI >= 32) { byteI -= 32; t.x += VGrid_Lib_BDraw_fontInfos[byteI].advance; } }
      t.x /= g.VGrid_Lib_BDraw_fontSize;
      ti.uvSize = t;
      VGrid_Lib_BDraw_textInfo(i, ti);
    }
    }
  }
  uint OpenHighLowCloseI(uint _dateI, uint _tickerI) { return _dateI * g.tickerN + _tickerI; }
  float4 OpenHighLowClose(uint _dateI, uint _tickerI) { return OpenHighLowCloses[OpenHighLowCloseI(_dateI, _tickerI)]; }
  [numthreads(numthreads2, numthreads2, 1)] void calc_uYearRanges(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.tickerN && id.x < g.dateN)
    {
      uint date_i = id.x, tck_i = id.y, yr_i = yr(dates[date_i]) - yr(dates[0]), i = yr_i * g.tickerN + tck_i;
      float3 ohl = OpenHighLowClose(date_i, tck_i).xyz;
      InterlockedMin(uYearRanges, i * 2, flooru(ohl.z * i2f()));
      InterlockedMax(uYearRanges, i * 2 + 1, flooru(ohl.y * i2f()));
      InterlockedAdd(yearTradeNs, yr_i, 1);
    }
    }
  }
  void OpenHighLowClose(uint _dateI, uint _tickerI, float4 v) { OpenHighLowCloses[OpenHighLowCloseI(_dateI, _tickerI)] = v; }
  [numthreads(numthreads2, numthreads2, 1)] void csv_to_OpenHighLowClose(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.tickerN && id.x < g.dateN)
    {
      uint _dateI = id.x, _tickerI = id.y, n = OHLC_N(), i = (_dateI + 1) * (g.tickerN * n + 1) + _tickerI * n + 1;
      float4 v = f0000;
      uint j = 0;
      if (g.includeOpen) v.x = csvFloat(i + (j++));
      if (g.includeHigh) v.y = csvFloat(i + (j++));
      if (g.includeLow) v.z = csvFloat(i + (j++));
      if (g.includeClose) v.w = csvFloat(i + (j++));
      OpenHighLowClose(_dateI, _tickerI == 0 ? 1 : _tickerI == 1 ? 0 : _tickerI, v);
    }
    }
  }
  SRule sRule() { return sRules[0]; }
  bool isAvgProjection() { return Is(sRule().sRule_avg_projections); }
  bool isWeightedAvg() { return Is(sRule().sRule_weighted_avg); }
  [numthreads(numthreads3, numthreads3, numthreads3)] void calcAvgs(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.z < 2 * (uint)AvgTypes_N * g.prevDayN && id.y < g.tickerN && id.x < g.dateN)
    {
      uint _dateI = id.x, _tckI = id.y, n = AvgTypes_N, n2 = n * 2, typI = id.z / g.prevDayN, typI2 = typI / 2, p_dayI = id.z % g.prevDayN,
          i = AvgI(_dateI, _tckI, g.movingAvgI, typI),
          date_j = (uint)max(0, (int)(_dateI - p_dayI - 1)), date_j1 = (uint)max(0, (int)(date_j - 1)), date_j2 = (uint)max(0, (int)(date_j - 2));
      float f = isWeightedAvg() ? max(0, (int)(g.prevDayN - p_dayI)) / (float)g.prevDayN : 1, v = 0;
      float2 hl = OpenHighLowClose(date_j, _tckI).yz, hl1 = OpenHighLowClose(date_j1, _tckI).yz, hl2 = OpenHighLowClose(date_j2, _tckI).yz;
      bool isHigh = !Is(typI % 2);
      if (typI2 == AvgTypes_Avg) v = isHigh ? hl.x : hl.y;
      else if (typI2 == AvgTypes_Slope) v = isHigh ? hl.x - hl1.x : hl.y - hl1.y;
      else if (typI2 == AvgTypes_Bend) v = isHigh ? (hl.x - hl1.x) - (hl1.x - hl2.x) : (hl.y - hl1.y) - (hl1.y - hl2.y);
      InterlockedAdd(avgs, i, roundi(v * f * 100));
    }
    }
  }
  uint DayN(uint _avgI) { return movingAvgs[_avgI].movingAvg_prevDayN; }
  float Avg(uint _dateI, uint _tckI, uint _avgI, uint t)
  {
    uint dyN = movingAvgs[_avgI].movingAvg_prevDayN;
    float f = isWeightedAvg() ? dyN / (dyN / 2.0f + 0.5f) : 1;
    return avgs[AvgI(_dateI, _tckI, _avgI, t)] / 100.0f / DayN(_avgI) * f;
  }
  float LowSlope(uint _dateI, uint _tckI, uint _avgI) { return Avg(_dateI, _tckI, _avgI, 3); }
  float LowBend(uint _dateI, uint _tckI, uint _avgI) { return Avg(_dateI, _tckI, _avgI, 5); }
  [numthreads(numthreads3, numthreads3, numthreads3)] void calcScores(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.z < g.movingAvgN * 2 && id.y < g.tickerN && id.x < g.dateN)
    {
      uint _dateI = id.x, _tckI = id.y, _movingAvgI = id.z % g.movingAvgN, slopeBend = id.z / g.movingAvgN, i = ScoreI(_dateI, _tckI);
      if (Is(validTrades[i]))
      {
        uint s = sRules[0].srule_score;
        float v = -10;
        if (s == RuleScore_slope0) v = LowSlope(_dateI, _tckI, 0);
        else if (s == RuleScore_slope1) v = LowSlope(_dateI, _tckI, 1);
        else if (s == RuleScore_slope2) v = LowSlope(_dateI, _tckI, 2);
        else if (s == RuleScore_bend0) v = LowBend(_dateI, _tckI, 0);
        else if (s == RuleScore_bend1) v = LowBend(_dateI, _tckI, 1);
        else if (s == RuleScore_bend2) v = LowBend(_dateI, _tckI, 2);
        InterlockedMax(scores, i, roundi(v * 1e6f));
      }
    }
    }
  }
  float LowAvg(uint _dateI, uint _tckI, uint _avgI) { return Avg(_dateI, _tckI, _avgI, 1); }
  float LowPredict(uint _dateI, uint _tckI, uint _avgI) { return LowAvg(_dateI, _tckI, _avgI) + LowSlope(_dateI, _tckI, _avgI) * DayN(_avgI) / (isWeightedAvg() ? 3 : 2); }
  float LowPredict2(uint _dateI, uint _tckI, uint _avgI) { return _dateI < 1 ? 0 : OpenHighLowClose(_dateI - 1, _tckI).z + LowPredict(_dateI, _tckI, _avgI) - LowPredict(_dateI - 1, _tckI, _avgI); }
  [numthreads(numthreads3, numthreads3, numthreads3)] void calcValidTrades(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.z < g.movingAvgN * 2 && id.y < g.tickerN && id.x < g.dateN)
    {
      uint _dateI = id.x, _tckI = id.y, _movingAvgI = id.z % g.movingAvgN, slopeBend = id.z / g.movingAvgN, i = ScoreI(_dateI, _tckI);
      float low = OpenHighLowClose(_dateI, _tckI).z;
      float predicted_low = _dateI < 1 ? 0 : isAvgProjection() ? LowPredict(_dateI, _tckI, _movingAvgI) : LowPredict2(_dateI, _tckI, _movingAvgI);
      uint v = 1;
      SRule rule = sRules[0];
      if (predicted_low < low) v = 0;
      else if (id.z == 0) { if (LowSlope(_dateI, _tckI, _movingAvgI) < rule.sRule_slope0) v = 0; }
      else if (id.z == 1) { if (LowSlope(_dateI, _tckI, _movingAvgI) < rule.sRule_slope1) v = 0; }
      else if (id.z == 2) { if (LowSlope(_dateI, _tckI, _movingAvgI) < rule.sRule_slope2) v = 0; }
      else if (id.z == 3) { if (LowBend(_dateI, _tckI, _movingAvgI) < rule.sRule_bend0) v = 0; }
      else if (id.z == 4) { if (LowBend(_dateI, _tckI, _movingAvgI) < rule.sRule_bend1) v = 0; }
      else if (id.z == 5) { if (LowBend(_dateI, _tckI, _movingAvgI) < rule.sRule_bend2) v = 0; }
      InterlockedMin(validTrades, i, v);
    }
    }
  }
  float HighAvg(uint _dateI, uint _tckI, uint _avgI) { return Avg(_dateI, _tckI, _avgI, 0); }
  float HighSlope(uint _dateI, uint _tckI, uint _avgI) { return Avg(_dateI, _tckI, _avgI, 2); }
  float HighPredict(uint _dateI, uint _tckI, uint _avgI) { return HighAvg(_dateI, _tckI, _avgI) + HighSlope(_dateI, _tckI, _avgI) * DayN(_avgI) / (isWeightedAvg() ? 3 : 2); }
  float HighPredict2(uint _dateI, uint _tckI, uint _avgI) { return _dateI < 1 ? 0 : OpenHighLowClose(_dateI - 1, _tckI).y + HighPredict(_dateI, _tckI, _avgI) - HighPredict(_dateI - 1, _tckI, _avgI); }
  [numthreads(numthreads1, 1, 1)] void calcDailySales(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.dateN)
    {
      uint _dateI = id.x;
      uint _tckI = (uint)maxDailyTickerScoreIs[_dateI];
      float3 ohl = OpenHighLowClose(_dateI, _tckI).xyz;
      float lt = isAvgProjection() ? LowPredict(_dateI, _tckI, g.movingAvgN - 1) : LowPredict2(_dateI, _tckI, g.movingAvgN - 1);
      float bought = min(ohl.x, lt);
      float sold = bought;
      uint daysHeld = 1;
      for (uint i = 1; i < 10 && _dateI + i < g.dateN; i++)
      {
        float ht = isAvgProjection() ? HighPredict(_dateI + i, _tckI, g.movingAvgN - 1) : HighPredict2(_dateI + i, _tckI, g.movingAvgN - 1);
        ohl = OpenHighLowClose(_dateI + i, _tckI).xyz;
        if (ht < ohl.y)
        {
          sold = max(ohl.x, ht);
          daysHeld = i;
          break;
        }
      }
      DailySale ds = dailySales[_dateI];
      ds.ds_tickerI = _tckI;
      ds.ds_buy_date = dates[_dateI];
      ds.ds_buy_price = bought;
      ds.ds_days_held = daysHeld;
      ds.ds_sell_price = sold;
      ds.ds_gain = gain(bought, sold);
      dailySales[_dateI] = ds;
    }
    }
  }
  float GEM_Lib_Get_tst_Pnt_Output(uint _levelI, float width, uint _tst_PntI, uint yI)
  {
    float2 vw = f00;
    for (uint pntI = 0; pntI < g.GEM_Lib_trnN; pntI++)
    {
      float dst2 = 0;
      for (uint xI = 0; xI < g.GEM_Lib_xN; xI++) dst2 += sqr(GEM_Lib_trnX(pntI, xI) - GEM_Lib_tstX_01(_tst_PntI, xI));
      float w = GEM_Lib_Basis(sqrt(dst2), width), y = GEM_Lib_trnC(_levelI, pntI, yI);
      vw += float2(y * w, w);
    }
    return vw.y == 0 ? 0 : vw.x * rcp(vw.y);
  }
  float GEM_Lib_Get_tst_Pnt_Output(uint _tst_PntI, uint yI)
  {
    float y = 0, width = g.GEM_Lib_maxBasisWidth;
    for (uint _levelI = 0; _levelI < g.GEM_Lib_levelN; _levelI++, width *= g.GEM_Lib_basisStep) y += GEM_Lib_Get_tst_Pnt_Output(_levelI, width, _tst_PntI, yI);
    return y;
  }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_calcMaxError(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.GEM_Lib_yN && id.x < g.GEM_Lib_tstN)
    {
      uint tst_PntI = id.x, yI = id.y;
      InterlockedMax(GEM_Lib_maxErrors, tst_PntI, GEM_Lib_f2u(g.GEM_Lib_trnN == 0 ? GEM_Lib_tstY(tst_PntI, yI) : g.GEM_Lib_trnN == 1 ? abs(1 - GEM_Lib_tstY(tst_PntI, yI)) : abs(GEM_Lib_Get_tst_Pnt_Output(tst_PntI, yI) - GEM_Lib_tstY(tst_PntI, yI))));
    }
    }
  }
  bool GEM_Lib_isInf(float v) { return v == fNegInf || v == fPosInf; }
  bool GEM_Lib_isNotInf(float v) { return !GEM_Lib_isInf(v); }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_Find_Ranges(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.GEM_Lib_xN + g.GEM_Lib_yN && id.x < g.GEM_Lib_trnN)
    {
      uint pntI = id.x, fldI = id.y, j = fldI * 2;
      float v = fldI < g.GEM_Lib_xN ? GEM_Lib_trnXYs[GEM_Lib_trnXI(pntI, fldI)] : GEM_Lib_trnXYs[GEM_Lib_trnYI(pntI, fldI - g.GEM_Lib_xN)];
      if (GEM_Lib_isNotInf(v))
      {
        int V = roundi(v * 100000);
        InterlockedMin(GEM_Lib_Ranges, j, V);
        InterlockedMax(GEM_Lib_Ranges, j + 1, V);
      }
    }
    }
  }
  void GEM_Lib_Set_trnInput(uint trnI, uint xI, float v) { GEM_Lib_trnXYs[trnI * g.GEM_Lib_xN + xI] = v; }
  float GEM_Lib_Get_trnInput(uint trnI, uint xI) { return trnI; }
  void GEM_Lib_assign_trnInput(uint trnI, uint xI) { GEM_Lib_Set_trnInput(trnI, xI, GEM_Lib_Get_trnInput(trnI, xI)); }
  void GEM_Lib_Set_trnOutput(uint trnI, uint yI, float v) { uint j = trnI * g.GEM_Lib_yN + yI; GEM_Lib_trnXYs[g.GEM_Lib_trnN * g.GEM_Lib_xN + j] = v; GEM_Lib_trnCs[j] = v; }
  float GEM_Lib_Get_trnOutput(uint trnI, uint yI) { return trnI; }
  void GEM_Lib_assign_trnOutput(uint trnI, uint yI) { GEM_Lib_Set_trnOutput(trnI, yI, GEM_Lib_Get_trnOutput(trnI, yI)); }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_assign_trn_Inputs_Outputs(uint3 id : SV_DispatchThreadID) { unchecked { if (id.y < g.GEM_Lib_xN + g.GEM_Lib_yN && id.x < g.GEM_Lib_trnN) { uint trnI = id.x, xI = id.y, yI = id.y - g.GEM_Lib_xN; if (xI < g.GEM_Lib_xN) GEM_Lib_assign_trnInput(trnI, xI); else GEM_Lib_assign_trnOutput(trnI, yI); } } }
  bool VGrid_Lib_BDraw_AppendBuff_IsBitOn(uint i) { uint c = VGrid_Lib_BDraw_Byte(i); return c == VGrid_Lib_BDraw_TB || c == VGrid_Lib_BDraw_LF; }
  uint VGrid_Lib_BDraw_AppendBuff_Assign_Bits(uint i, uint j, uint bits) { return bits | (Is(i < g.VGrid_Lib_BDraw_AppendBuff_N && VGrid_Lib_BDraw_AppendBuff_IsBitOn(i)) << (int)j); }
  [numthreads(numthreads1, 1, 1)] void VGrid_Lib_BDraw_AppendBuff_GetSums(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
  {
    uint i = id.x, c, s, j, k, bits = 0;
    if (i < g.VGrid_Lib_BDraw_AppendBuff_BitN) { for (j = 0, k = i * 32; j < 32; j++) bits = VGrid_Lib_BDraw_AppendBuff_Assign_Bits(k + j, j, bits); VGrid_Lib_BDraw_AppendBuff_Bits[i] = bits; c = countbits(bits); } else c = 0;
    VGrid_Lib_BDraw_AppendBuff_grp0[grpI] = c; VGrid_Lib_BDraw_AppendBuff_grp[grpI] = c; GroupMemoryBarrierWithGroupSync();
    for (s = 1; s < numthreads1; s *= 2)
    {
      if (grpI >= s && i < g.VGrid_Lib_BDraw_AppendBuff_BitN) VGrid_Lib_BDraw_AppendBuff_grp[grpI] = VGrid_Lib_BDraw_AppendBuff_grp0[grpI] + VGrid_Lib_BDraw_AppendBuff_grp0[grpI - s]; GroupMemoryBarrierWithGroupSync();
      VGrid_Lib_BDraw_AppendBuff_grp0[grpI] = VGrid_Lib_BDraw_AppendBuff_grp[grpI]; GroupMemoryBarrierWithGroupSync();
    }
    if (i < g.VGrid_Lib_BDraw_AppendBuff_BitN) VGrid_Lib_BDraw_AppendBuff_Sums[i] = VGrid_Lib_BDraw_AppendBuff_grp[grpI];
  }
  [numthreads(numthreads1, 1, 1)] void VGrid_Lib_BDraw_AppendBuff_Get_Bits(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.VGrid_Lib_BDraw_AppendBuff_BitN) { uint i = id.x, j, k, bits = 0; if (i < g.VGrid_Lib_BDraw_AppendBuff_BitN) { for (j = 0, k = i * 32; j < 32; j++) bits = VGrid_Lib_BDraw_AppendBuff_Assign_Bits(k + j, j, bits); VGrid_Lib_BDraw_AppendBuff_Bits[i] = bits; } } } }
  VGrid_Lib_TRay VGrid_Lib_CreateRayHit() { VGrid_Lib_TRay hit; hit.origin = f000; hit.dist = fPosInf; hit.direction = f000; hit.color = f0000; return hit; }
  float3 VGrid_Lib_gridMin() { return float3(g.VGrid_Lib_GridX.x, g.VGrid_Lib_GridY.x, g.VGrid_Lib_GridZ.x); }
  float3 VGrid_Lib_NodeLocation3(uint3 id) { return id * g.VGrid_Lib_resolution + VGrid_Lib_gridMin(); }
  float3 VGrid_Lib_gridMax() { return float3(g.VGrid_Lib_GridX.y, g.VGrid_Lib_GridY.y, g.VGrid_Lib_GridZ.y); }
  void VGrid_Lib_Assign(inout VGrid_Lib_TRay hit, float3 position, float3 normal, float4 color, float dist) { hit.origin = position; hit.direction = normal; hit.color = color; hit.dist = dist; }
  void VGrid_Lib_pixDepthColor(uint i, float d, float4 c) { VGrid_Lib_depthColors[i] = uint2((uint)(d / g.VGrid_Lib_maxDist * uint_max), c32_u(f4_c32(c))); }
  void VGrid_Lib_pixDepthColor(uint2 id, float d, float4 c) { VGrid_Lib_pixDepthColor(id_to_i(id, g.VGrid_Lib_viewSize), d, c); }
  void VGrid_Lib_Val(uint i, float v) { VGrid_Lib_Vals[i] = v; }
  uint VGrid_Lib_NodeI(uint3 id) { return id_to_i(id, g.VGrid_Lib_nodeN); }
  bool isAny(uint c, uint a, uint b) { return c == a || c == b; }
  uint txtByte(uint i) { return TextByte(csvText, i); }
  bool AppendBuff_IsBitOn(uint i) { return g.appendBuffMode == AppendBuffMode_FindTabs ? isAny(txtByte(i), ASCII_HT, ASCII_LF)
      : i == 0 || yr(dates[i]) > yr(dates[i - 1]); }
  uint AppendBuff_Assign_Bits(uint i, uint j, uint bits) { return bits | (Is(i < g.AppendBuff_N && AppendBuff_IsBitOn(i)) << (int)j); }
  [numthreads(numthreads1, 1, 1)] void AppendBuff_GetSums(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
  {
    uint i = id.x, c, s, j, k, bits = 0;
    if (i < g.AppendBuff_BitN) { for (j = 0, k = i * 32; j < 32; j++) bits = AppendBuff_Assign_Bits(k + j, j, bits); AppendBuff_Bits[i] = bits; c = countbits(bits); } else c = 0;
    AppendBuff_grp0[grpI] = c; AppendBuff_grp[grpI] = c; GroupMemoryBarrierWithGroupSync();
    for (s = 1; s < numthreads1; s *= 2)
    {
      if (grpI >= s && i < g.AppendBuff_BitN) AppendBuff_grp[grpI] = AppendBuff_grp0[grpI] + AppendBuff_grp0[grpI - s]; GroupMemoryBarrierWithGroupSync();
      AppendBuff_grp0[grpI] = AppendBuff_grp[grpI]; GroupMemoryBarrierWithGroupSync();
    }
    if (i < g.AppendBuff_BitN) AppendBuff_Sums[i] = AppendBuff_grp[grpI];
  }
  [numthreads(numthreads1, 1, 1)] void AppendBuff_Get_Bits(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.AppendBuff_BitN) { uint i = id.x, j, k, bits = 0; if (i < g.AppendBuff_BitN) { for (j = 0, k = i * 32; j < 32; j++) bits = AppendBuff_Assign_Bits(k + j, j, bits); AppendBuff_Bits[i] = bits; } } } }
  float GEM_Lib_trnXY(uint pntI, uint xyI) { return xyI < g.GEM_Lib_xN ? GEM_Lib_trnX(pntI, xyI) : GEM_Lib_trnY(pntI, xyI - g.GEM_Lib_xN); }
  float GEM_Lib_trnX_01(uint pntI, uint xI) { return GEM_Lib_trnXYs[GEM_Lib_trnXI(pntI, xI)]; }
  float GEM_Lib_trnY_01(uint pntI, uint yI) { return lerp1(GEM_Lib_ranges[g.GEM_Lib_xN + yI], GEM_Lib_trnXYs[GEM_Lib_trnYI(pntI, yI)]); }
  float GEM_Lib_tstY_01(uint _tstI, uint yI) { return lerp1(GEM_Lib_ranges[g.GEM_Lib_xN + yI], GEM_Lib_tstY(_tstI, yI)); }
  bool GEM_Lib_AppendBuff_IsBitOn(uint i)
  {
    switch ((uint)g.GEM_Lib_findMode)
    {
      case GEM_Lib_Find_Mode_Unknowns: { uint n = g.GEM_Lib_xN + g.GEM_Lib_yN, pntI = i / n, xyI = i % n; return GEM_Lib_isInf(GEM_Lib_trnXY(pntI, xyI)); }
      case GEM_Lib_Find_Mode_K_U: { bool on = false; for (uint xI = 0; !on && xI < g.GEM_Lib_xN; xI++) on = GEM_Lib_isInf(GEM_Lib_trnXY(i, xI)); if (!(on = !on)) { for (uint yI = 0; on && yI < g.GEM_Lib_yN; yI++) on = GEM_Lib_isNotInf(GEM_Lib_trnXY(i, g.GEM_Lib_xN + yI)); on = !on; } return on; }
      case GEM_Lib_Find_Mode_Outliers: default: { uint n = g.GEM_Lib_xN + g.GEM_Lib_yN, pntI = i / n, xyI = i % n, yI = xyI - g.GEM_Lib_xN; return abs(xyI < g.GEM_Lib_xN ? GEM_Lib_trnX_01(pntI, xyI) - GEM_Lib_tstX_01(pntI, xyI) : GEM_Lib_trnY_01(pntI, yI) - GEM_Lib_tstY_01(pntI, yI)) > g.GEM_Lib_outlier_tolerance; }
    }
  }
  uint GEM_Lib_AppendBuff_Assign_Bits(uint i, uint j, uint bits) { return bits | (Is(i < g.GEM_Lib_AppendBuff_N && GEM_Lib_AppendBuff_IsBitOn(i)) << (int)j); }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_AppendBuff_GetSums(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
  {
    uint i = id.x, c, s, j, k, bits = 0;
    if (i < g.GEM_Lib_AppendBuff_BitN) { for (j = 0, k = i * 32; j < 32; j++) bits = GEM_Lib_AppendBuff_Assign_Bits(k + j, j, bits); GEM_Lib_AppendBuff_Bits[i] = bits; c = countbits(bits); } else c = 0;
    GEM_Lib_AppendBuff_grp0[grpI] = c; GEM_Lib_AppendBuff_grp[grpI] = c; GroupMemoryBarrierWithGroupSync();
    for (s = 1; s < numthreads1; s *= 2)
    {
      if (grpI >= s && i < g.GEM_Lib_AppendBuff_BitN) GEM_Lib_AppendBuff_grp[grpI] = GEM_Lib_AppendBuff_grp0[grpI] + GEM_Lib_AppendBuff_grp0[grpI - s]; GroupMemoryBarrierWithGroupSync();
      GEM_Lib_AppendBuff_grp0[grpI] = GEM_Lib_AppendBuff_grp[grpI]; GroupMemoryBarrierWithGroupSync();
    }
    if (i < g.GEM_Lib_AppendBuff_BitN) GEM_Lib_AppendBuff_Sums[i] = GEM_Lib_AppendBuff_grp[grpI];
  }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_AppendBuff_Get_Bits(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_AppendBuff_BitN) { uint i = id.x, j, k, bits = 0; if (i < g.GEM_Lib_AppendBuff_BitN) { for (j = 0, k = i * 32; j < 32; j++) bits = GEM_Lib_AppendBuff_Assign_Bits(k + j, j, bits); GEM_Lib_AppendBuff_Bits[i] = bits; } } } }
  float GEM_Lib_getSearchOutput(uint _levelI, float width, uint searchI, uint yI)
  {
    float2 vw = f00;
    for (uint pntI = 0; pntI < g.GEM_Lib_trnN; pntI++)
    {
      float dst2 = 0;
      for (uint xI = 0; xI < g.GEM_Lib_xN; xI++) dst2 += sqr(GEM_Lib_trnX(pntI, xI) - GEM_Lib_searchPntX(searchI, xI));
      float w = GEM_Lib_Basis(sqrt(dst2), width), y = GEM_Lib_trnC(_levelI, pntI, yI);
      vw += float2(y * w, w);
    }
    bool lev0 = _levelI == 0;
    return lev0 && vw.y == 0 ? 0 : vw.x * rcp(lev0 ? vw.y : max(vw.y, 1));
  }
  float GEM_Lib_getSearchOutput(uint searchI, uint yI)
  {
    float y = 0, width = g.GEM_Lib_maxBasisWidth;
    for (uint _levelI = 0; _levelI < g.GEM_Lib_levelN; _levelI++, width *= g.GEM_Lib_basisStep) y += GEM_Lib_getSearchOutput(_levelI, width, searchI, yI);
    return y;
  }
  float GEM_Lib_searchPnt_v(uint pntI, uint xI) { return xI < g.GEM_Lib_xN ? GEM_Lib_searchPnts[GEM_Lib_searchPntI(pntI, xI)] : GEM_Lib_getSearchOutput(pntI, xI - g.GEM_Lib_xN); }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_calc_wx(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.GEM_Lib_searchPntN && id.x < g.GEM_Lib_xN)
    {
      uint xI = id.x, searchI = id.y;
      float dx = GEM_Lib_bestInputs[xI];
      uint score = GEM_Lib_scores[searchI], mnScore = GEM_Lib_scores[GEM_Lib_uints[GEM_Lib_UInts_mnScoreI]], mxScore = GEM_Lib_scores[GEM_Lib_uints[GEM_Lib_UInts_mxScoreI]], avgScore = mxScore / 2 + mnScore / 2;
      if (score > avgScore)
      {
        score -= avgScore;
        float x = GEM_Lib_searchPnt_v(searchI, xI) - dx, w = score / 1e6f, sum_w = GEM_Lib_uints[GEM_Lib_UInts_sum_w] / 1e6f;
        int WX = roundi(w * x / sum_w * 1e6f);
        InterlockedAdd(GEM_Lib_wx, xI, WX);
      }
    }
    }
  }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_calc_Scores(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.GEM_Lib_xN + g.GEM_Lib_yN && id.x < g.GEM_Lib_searchPntN)
    {
      uint searchI = id.x, xyI = id.y;
      float2 vw = GEM_Lib_desiredValWeights[xyI];
      float v = abs(GEM_Lib_searchPnt_v(searchI, xyI) - vw.x) * vw.y;
      uint Score = roundu(v * 1e6f);
      InterlockedAdd(GEM_Lib_scores, searchI, Score);
    }
    }
  }
  VGrid_Lib_TRay VGrid_Lib_CreateShaderCameraRay(float2 _uv)
  {
    VGrid_Lib_TRay ray;
    ray.origin = mul(g.VGrid_Lib_camToWorld, g.VGrid_Lib_isOrtho ? float4(g.VGrid_Lib_orthoSize * _uv / float2(aspect(g.VGrid_Lib_viewSize), 1), 0, 1) : f0001).xyz;
    ray.direction = normalize(mul(g.VGrid_Lib_camToWorld, float4(mul(g.VGrid_Lib_cameraInvProjection, float4(_uv, 0, 1)).xyz, 0)).xyz);
    ray.color = f0000;
    ray.dist = 0;
    return ray;
  }
  VGrid_Lib_TRay VGrid_Lib_CreateRay(float3 origin, float3 direction) { VGrid_Lib_TRay ray; ray.origin = origin; ray.direction = direction; ray.color = f0000; ray.dist = 0; return ray; }
  VGrid_Lib_TRay VGrid_Lib_CreateCameraRay(float2 _uv) { VGrid_Lib_TRay ray = VGrid_Lib_CreateShaderCameraRay(_uv); return VGrid_Lib_CreateRay(ray.origin, ray.direction); }
  float VGrid_Lib_Val(uint i) { return VGrid_Lib_Vals[i]; }
  float4 VGrid_Lib_DrawSliceColor(float4 color, float3 q) { return color; }
  uint GEM_Lib_Rand_UV(uint4 r) { return cxor(r); }
  float GEM_Lib_Rand_FV(uint4 r) { return 2.3283064365387e-10f * GEM_Lib_Rand_UV(r); }
  float3 VGrid_Lib_GetCorner_q(float3 p) { return clamp((p - VGrid_Lib_gridMin()) / g.VGrid_Lib_resolution, f000, (int3)g.VGrid_Lib_nodeN - f111); }
  uint3 VGrid_Lib_GetCorner_I(float3 q) { return (uint3)q; }
  float VGrid_Lib_Interpolate_Val(float3 fq, uint4 c0, uint4 c1) { return Interpolate(VGrid_Lib_Val(c0.x), VGrid_Lib_Val(c0.y), VGrid_Lib_Val(c0.z), VGrid_Lib_Val(c0.w), VGrid_Lib_Val(c1.x), VGrid_Lib_Val(c1.y), VGrid_Lib_Val(c1.z), VGrid_Lib_Val(c1.w), fq); }
  uint Rand_UV(uint4 r) { return cxor(r); }
  float Rand_FV(uint4 r) { return 2.3283064365387e-10f * Rand_UV(r); }
  float4 VGrid_Lib_paletteBufferColor(float v) { return c32_f4(VGrid_Lib_paletteBuffer[roundu(clamp(v * 255, 0, 255))]); }
  float4 VGrid_Lib_GetPointColor(float3 p, float val) { return VGrid_Lib_paletteBufferColor(lerp1(g.VGrid_Lib_paletteRange, val)); }
  float4 VGrid_Lib_GetNormalColor(VGrid_Lib_TRay ray, float3 normal, float val, float3 p)
  {
    float3 lightDirection = _WorldSpaceLightPos0.xyz;
    float3 h = (lightDirection - ray.direction) / 2;
    float v = 1, gloss = 0.5f, s = sqr(abs(dot(normal, h))) * gloss, NdotL = abs(dot(normal, lightDirection));
    if (g.VGrid_Lib_GridLineThickness > 0)
    {
      float w = 1 / max(0.00001f, g.VGrid_Lib_GridLineThickness);
      p /= g.VGrid_Lib_resolution;
      float3 blend = normalize(max((abs(normal) - 0.2f) * 7, 0.0f));
      v = csum(blend * saturate(0.5f * float3(product((1 - abs(1 - 2 * frac(p.yz))) * w), product((1 - abs(1 - 2 * frac(p.xz))) * w), product((1 - abs(1 - 2 * frac(p.xy))) * w))));
    }
    return float4(saturate((VGrid_Lib_GetPointColor(p, val).xyz * (NdotL + 0.5f) + s) * v), g.VGrid_Lib_opacity);
  }
  uint GEM_Lib_Rand_u(uint a, int b, int c, int d, uint e) { return ((a & e) << d) ^ (((a << b) ^ a) >> c); }
  uint4 GEM_Lib_Rand_U4(uint4 r) { return uint4(GEM_Lib_Rand_u(r.x, 13, 19, 12, 4294967294u), GEM_Lib_Rand_u(r.y, 2, 25, 4, 4294967288u), GEM_Lib_Rand_u(r.z, 3, 11, 17, 4294967280u), r.w * 1664525 + 1013904223u); }
  uint4 GEM_Lib_Rand_rUInt4(uint i) { return GEM_Lib_Rand_U4(GEM_Lib_Rand_rs[i]); }
  uint4 GEM_Lib_Rand_UInt4(uint i) { return GEM_Lib_Rand_rs[i] = GEM_Lib_Rand_rUInt4(i); }
  float GEM_Lib_Rand_Float(uint i) { return GEM_Lib_Rand_FV(GEM_Lib_Rand_UInt4(i)); }
  float GEM_Lib_Rand_Float(uint i, float A, float B) { return lerp(A, B, GEM_Lib_Rand_Float(i)); }
  [numthreads(numthreads2, numthreads2, 1)] void GEM_Lib_find_search_Pnts(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.y < g.GEM_Lib_xN && id.x < g.GEM_Lib_searchPntN)
    {
      uint searchI = id.x, xI = id.y;
      if (searchI == 0) GEM_Lib_searchPntX(searchI, xI, GEM_Lib_w_avg_Xs[xI]);
      else
      {
        float2 dw = GEM_Lib_desiredValWeights[xI];
        float v = GEM_Lib_bestInputs[xI], r = g.GEM_Lib_searchRadius, x = dw.y >= 0.99f ? dw.x : GEM_Lib_Rand_Float(GEM_Lib_searchPntI(searchI, xI), max(0, v - r), min(1, v + r));
        GEM_Lib_searchPntX(searchI, xI, x);
      }
    }
    }
  }
  uint GEM_Lib_Rand_UInt(uint i, uint A, uint B) { return flooru(GEM_Lib_Rand_Float(i, A, B)); }
  [numthreads(numthreads1, 1, 1)] void GEM_Lib_Rand_initState(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.GEM_Lib_Rand_I) { uint i = id.x + g.GEM_Lib_Rand_I; if (i < g.GEM_Lib_Rand_N) GEM_Lib_Rand_rs[i] = index(GEM_Lib_Rand_rs[i], g.GEM_Lib_Rand_J, GEM_Lib_Rand_UInt(id.x, 0, uint_max)); } } }
  uint Rand_u(uint a, int b, int c, int d, uint e) { return ((a & e) << d) ^ (((a << b) ^ a) >> c); }
  uint4 Rand_U4(uint4 r) { return uint4(Rand_u(r.x, 13, 19, 12, 4294967294u), Rand_u(r.y, 2, 25, 4, 4294967288u), Rand_u(r.z, 3, 11, 17, 4294967280u), r.w * 1664525 + 1013904223u); }
  uint4 Rand_rUInt4(uint i) { return Rand_U4(Rand_rs[i]); }
  uint4 Rand_UInt4(uint i) { return Rand_rs[i] = Rand_rUInt4(i); }
  float Rand_Float(uint i) { return Rand_FV(Rand_UInt4(i)); }
  float Rand_Float(uint i, float A, float B) { return lerp(A, B, Rand_Float(i)); }
  uint Rand_UInt(uint i, uint A, uint B) { return flooru(Rand_Float(i, A, B)); }
  [numthreads(numthreads1, 1, 1)] void Rand_initState(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.Rand_I) { uint i = id.x + g.Rand_I; if (i < g.Rand_N) Rand_rs[i] = index(Rand_rs[i], g.Rand_J, Rand_UInt(id.x, 0, uint_max)); } } }
  uint3 VGrid_Lib_nodeN1() { return max(g.VGrid_Lib_nodeN, u111) - u111; }
  uint VGrid_Lib_GridToIndex(int3 _I) { return id_to_i(clamp(_I, u000, VGrid_Lib_nodeN1()), g.VGrid_Lib_nodeN); }
  uint4 VGrid_Lib_GetFaceI(uint3 _I, int3 x, int3 y, int3 z, int3 w) { return new uint4(VGrid_Lib_GridToIndex((int3)_I + x), VGrid_Lib_GridToIndex((int3)_I + y), VGrid_Lib_GridToIndex((int3)_I + z), VGrid_Lib_GridToIndex((int3)_I + w)); }
  uint4 VGrid_Lib_GetFaceI(uint3 _I, int3 d) { return VGrid_Lib_GetFaceI(_I, i000 + d, i001 + d, i010 + d, i011 + d); }
  float VGrid_Lib_Val(float3 p) { float3 q = VGrid_Lib_GetCorner_q(p); uint3 _I = VGrid_Lib_GetCorner_I(q); return VGrid_Lib_Interpolate_Val(frac(q), VGrid_Lib_GetFaceI(_I, i000), VGrid_Lib_GetFaceI(_I, i100)); }
  float VGrid_Lib_setDepth(float depth, VGrid_Lib_TRay ray, inout float3 p, inout float val) { p = depth * ray.direction + ray.origin; val = VGrid_Lib_Val(p); return depth; }
  void VGrid_Lib_DrawSlice(float3 axis, VGrid_Lib_TRay ray, inout VGrid_Lib_TRay hit, inout float3 p, inout float val, inout float depth, inout bool found, inout float4 color, float3 normal)
  {
    float depth_slice;
    float3 axis2 = rotateZYXDeg(axis, g.VGrid_Lib_sliceRotation), q = PlaneLineIntersectionPoint(axis2, g.VGrid_Lib_slices, ray.origin, ray.direction);
    if (q.x != fNegInf && IsNotOutside(q, VGrid_Lib_gridMin(), VGrid_Lib_gridMax()))
    {
      depth_slice = VGrid_Lib_setDepth(max(distance(q, ray.origin), 0.018f), ray, p, val);
      if (depth_slice < depth) { found = true; depth = depth_slice; color = VGrid_Lib_DrawSliceColor(VGrid_Lib_GetNormalColor(ray, axis2, val, p), q); VGrid_Lib_Assign(hit, p, normal, color, depth); }
    }
  }
  float3 VGrid_Lib_Val(float3 p, float d) { return float3(VGrid_Lib_Val(p + f100 * d), VGrid_Lib_Val(p + f010 * d), VGrid_Lib_Val(p + f001 * d)); }
  void VGrid_Lib_Val3(uint3 id, float v) { VGrid_Lib_Val(VGrid_Lib_NodeI(id), v); }
  [numthreads(numthreads3, numthreads3, numthreads3)] void VGrid_Lib_Grid_Calc_Vals(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (all(id < g.VGrid_Lib_nodeN))
    {
      float3 p = VGrid_Lib_NodeLocation3(id);
      float R = 0.3333f, v = sqr(length(p.xz) - R) + sqr(p.y);
      VGrid_Lib_Val3(id, v * 10);
    }
    }
  }
  float3 VGrid_Lib_Normal(float3 p)
  {
    float r = g.VGrid_Lib_resolution * 0.5f, margin = r * 0.02f;
    float3 normal = p <= VGrid_Lib_gridMin() + margin;
    if (all(normal == f000)) normal = p >= VGrid_Lib_gridMax() - margin;
    if (all(normal == f000)) normal = normalize(VGrid_Lib_Val(p, r) - VGrid_Lib_Val(p, -r));
    return normal;
  }
  float4 VGrid_Lib_GetColor(VGrid_Lib_TRay ray, inout float3 normal, float val, float3 p) { return VGrid_Lib_GetNormalColor(ray, normal = VGrid_Lib_Normal(p), val, p); }
  void VGrid_Lib_TraceRay(uint3 id, bool isSimple)
  {
    VGrid_Lib_TRay ray = VGrid_Lib_CreateCameraRay(2.0f * id.xy / g.VGrid_Lib_viewSize - 1), hit = VGrid_Lib_CreateRayHit();
    float3 mn = VGrid_Lib_gridMin(), mx = max(mn + 0.001f, VGrid_Lib_gridMax());
    float2 dst = HitGridBox(mn, mx, ray.origin, ray.direction);
    bool hitOutside = HitOutsideGrid(dst), hitInside = HitInsideGrid(dst);
    if (hitOutside || hitInside)
    {
      float3 p = f000, normal = f100;
      float val = 0, depth = VGrid_Lib_setDepth(max(dst.x, 0.018f), ray, p, val), depth2 = dst.y, step = g.VGrid_Lib_resolution, d0, d2;
      bool found = false;
      float4 color = f0000;
      if (g.VGrid_Lib_GridDrawFront && hitOutside) { color = VGrid_Lib_GetColor(ray, normal, val, p); VGrid_Lib_Assign(hit, p, normal, color, depth); }
      else
      {
        float val0 = val;
        if (isSimple)
        {
          float v = g.VGrid_Lib_meshVal;
          for (uint i = 0, n = csum(g.VGrid_Lib_nodeN); i < n && !found; i++)
          {
            if (val0 > v && val <= v)
            {
              val0 = val;
              for (d0 = max(0, depth - step), d2 = depth; d2 - d0 > step / 100;) { depth = VGrid_Lib_setDepth((d0 + d2) / 2, ray, p, val); if (val > v) d0 = depth; else d2 = depth; }
              color = VGrid_Lib_GetColor(ray, normal, val, p);
              VGrid_Lib_Assign(hit, p, normal, color, depth); found = true;
            }
            else if (val0 < v && val >= v)
            {
              val0 = val;
              for (d0 = depth - step, d2 = depth; d2 - d0 > step / 100;) { depth = VGrid_Lib_setDepth((d0 + d2) / 2, ray, p, val); if (val < v) d0 = depth; else d2 = depth; }
              if (depth + step < depth2)
              {
                color = VGrid_Lib_GetColor(ray, normal, val, p);
                VGrid_Lib_Assign(hit, p, normal, color, depth); found = true;
              }
            }
            else val0 = val;
            if (depth + step > depth2) { depth = VGrid_Lib_setDepth(depth2, ray, p, val); break; }
            depth = VGrid_Lib_setDepth(depth + step, ray, p, val);
          }
        }
        else
        {
          for (uint i = 0, n = csum(g.VGrid_Lib_nodeN); i < n && (g.VGrid_Lib_opacity < 0.999f || !found); i++)
          {
            if (i == 0 && hitOutside && val <= g.VGrid_Lib_meshRange.y && val >= g.VGrid_Lib_meshRange.x)
            {
              val0 = val;
              color = VGrid_Lib_GetColor(ray, normal, val, p);
              VGrid_Lib_Assign(hit, p, normal, color, depth);
              found = true;
            }
            else if (val0 > g.VGrid_Lib_meshRange.y && val <= g.VGrid_Lib_meshRange.y)
            {
              val0 = val;
              for (d0 = max(0, depth - step), d2 = depth; d2 - d0 > step / 100;) { depth = VGrid_Lib_setDepth((d0 + d2) / 2, ray, p, val); if (val > g.VGrid_Lib_meshRange.y) d0 = depth; else d2 = depth; }
              color = VGrid_Lib_GetColor(ray, normal, val, p);
              if (!found) { VGrid_Lib_Assign(hit, p, normal, color, depth); found = true; }
              else hit.color.xyz = g.VGrid_Lib_opacity * hit.color.xyz + (1 - g.VGrid_Lib_opacity) * color.xyz;
            }
            else if (val0 < g.VGrid_Lib_meshRange.x && val >= g.VGrid_Lib_meshRange.x)
            {
              val0 = val;
              for (d0 = depth - step, d2 = depth; d2 - d0 > step / 100;) { depth = VGrid_Lib_setDepth((d0 + d2) / 2, ray, p, val); if (val < g.VGrid_Lib_meshRange.x) d0 = depth; else d2 = depth; }
              if (depth + step < depth2)
              {
                color = VGrid_Lib_GetColor(ray, normal, val, p);
                if (!found) { VGrid_Lib_Assign(hit, p, normal, color, depth); found = true; }
                else hit.color.xyz = g.VGrid_Lib_opacity * hit.color.xyz + (1 - g.VGrid_Lib_opacity) * color.xyz;
              }
            }
            else if (val0 > g.VGrid_Lib_meshRange.x && val <= g.VGrid_Lib_meshRange.x)
            {
              val0 = val;
              for (d0 = depth - step, d2 = depth; d2 - d0 > step / 100;) { depth = VGrid_Lib_setDepth((d0 + d2) / 2, ray, p, val); if (val > g.VGrid_Lib_meshRange.x) d0 = depth; else d2 = depth; }
              color = VGrid_Lib_GetColor(ray, normal, val, p);
              if (!found) { VGrid_Lib_Assign(hit, p, normal, color, depth); found = true; }
              else hit.color.xyz = g.VGrid_Lib_opacity * hit.color.xyz + (1 - g.VGrid_Lib_opacity) * color.xyz;
            }
            else if (val0 < g.VGrid_Lib_meshRange.y && val >= g.VGrid_Lib_meshRange.y)
            {
              val0 = val;
              for (d0 = depth - step, d2 = depth; d2 - d0 > step / 100;) { depth = VGrid_Lib_setDepth((d0 + d2) / 2, ray, p, val); if (val < g.VGrid_Lib_meshRange.y) d0 = depth; else d2 = depth; }
              color = VGrid_Lib_GetColor(ray, normal, val, p);
              if (!found) { VGrid_Lib_Assign(hit, p, normal, color, depth); found = true; }
              else hit.color.xyz = g.VGrid_Lib_opacity * hit.color.xyz + (1 - g.VGrid_Lib_opacity) * color.xyz;
            }
            else if (hitInside && depth > step / 2 && val0 > g.VGrid_Lib_meshRange.x && val <= g.VGrid_Lib_meshRange.x)
            {
              val0 = val;
              for (d0 = depth - step, d2 = depth; d2 - d0 > step / 100;) { depth = VGrid_Lib_setDepth((d0 + d2) / 2, ray, p, val); if (val > g.VGrid_Lib_meshRange.x) d0 = depth; else d2 = depth; }
              color = VGrid_Lib_GetColor(ray, normal, val, p);
              if (!found) { VGrid_Lib_Assign(hit, p, normal, color, depth); found = true; }
              else hit.color.xyz = g.VGrid_Lib_opacity * hit.color.xyz + (1 - g.VGrid_Lib_opacity) * color.xyz;
            }
            else val0 = val;
            if (depth + step > depth2) { depth = VGrid_Lib_setDepth(depth2, ray, p, val); break; }
            depth = VGrid_Lib_setDepth(depth + step, ray, p, val);
          }
        }
        if (g.VGrid_Lib_show_slices) for (uint i = 0; i < 3; i++) VGrid_Lib_DrawSlice(index(f000, i, 1.0f), ray, hit, p, val, depth, found, color, normal);
        if (g.VGrid_Lib_GridDrawBack)
        {
          color = VGrid_Lib_GetColor(ray, normal, val, p);
          if (!found) VGrid_Lib_Assign(hit, p, normal, color, depth);
          else hit.color.xyz = g.VGrid_Lib_opacity * hit.color.xyz + (1 - g.VGrid_Lib_opacity) * color.xyz;
        }
      }
    }
    VGrid_Lib_pixDepthColor(id.xy, hit.dist, hit.color);
  }
  [numthreads(numthreads2, numthreads2, 1)] void VGrid_Lib_Grid_Simple_TraceRay(uint3 id : SV_DispatchThreadID) { unchecked { if (all(id.xy < g.VGrid_Lib_viewSize)) { VGrid_Lib_TraceRay(id, true); } } }
  [numthreads(numthreads2, numthreads2, 1)] void VGrid_Lib_Grid_TraceRay(uint3 id : SV_DispatchThreadID) { unchecked { if (all(id.xy < g.VGrid_Lib_viewSize)) { VGrid_Lib_TraceRay(id, false); } } }
  [numthreads(numthreads1, 1, 1)] void csvParseText(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.dateN)
    {
      uint i = id.x, j = (g.csvHeaderN + i) * g.csvColN;
      Trade trade = trades[i];
      trade.date = ToUInt(csvText, Get_tab_indexes(j));
      trade.open = ToFloat(csvText, Get_tab_indexes(j + 1));
      trade.high = ToFloat(csvText, Get_tab_indexes(j + 2));
      trade.low = ToFloat(csvText, Get_tab_indexes(j + 3));
      trade.close = ToFloat(csvText, Get_tab_indexes(j + 4));
      trade.volume = ToFloat(csvText, Get_tab_indexes(j + 5));
      trades[i] = trade;
    }
    }
  }
  #pragma kernel Find_startTestDayIndex
  #pragma kernel csvParseText
  #pragma kernel calc_yearRanges
  #pragma kernel calc_uYearRanges
  #pragma kernel init_uYearRanges
  #pragma kernel findStartYearIs
  #pragma kernel csv_to_dates
  #pragma kernel csv_to_OpenHighLowClose
  #pragma kernel initAvgs
  #pragma kernel calcDailySales
  #pragma kernel calcAvgs
  #pragma kernel findDailyTickerScoreIs
  #pragma kernel findDailyTickerScores
  #pragma kernel initDailyTickerScores
  #pragma kernel calcScores
  #pragma kernel initScores
  #pragma kernel calcValidTrades
  #pragma kernel initValidTrades
  #pragma kernel Sort_Lib_counts_to_sorts
  #pragma kernel Sort_Lib_add_counts_triangle
  #pragma kernel Sort_Lib_init_counts
  #pragma kernel AppendBuff_GetIndexes
  #pragma kernel AppendBuff_IncSums
  #pragma kernel AppendBuff_IncFills1
  #pragma kernel AppendBuff_GetFills2
  #pragma kernel AppendBuff_GetFills1
  #pragma kernel AppendBuff_Get_Bits_Sums
  #pragma kernel AppendBuff_GetSums
  #pragma kernel AppendBuff_Get_Bits
  #pragma kernel Rand_initState
  #pragma kernel Rand_initSeed
  #pragma kernel GEM_Lib_Rand_initState
  #pragma kernel GEM_Lib_Rand_initSeed
  #pragma kernel GEM_Lib_AppendBuff_GetIndexes
  #pragma kernel GEM_Lib_AppendBuff_IncSums
  #pragma kernel GEM_Lib_AppendBuff_IncFills1
  #pragma kernel GEM_Lib_AppendBuff_GetFills2
  #pragma kernel GEM_Lib_AppendBuff_GetFills1
  #pragma kernel GEM_Lib_AppendBuff_Get_Bits_Sums
  #pragma kernel GEM_Lib_AppendBuff_GetSums
  #pragma kernel GEM_Lib_AppendBuff_Get_Bits
  #pragma kernel GEM_Lib_remove_maxError_tst_Pnt
  #pragma kernel GEM_Lib_copy_tst_Pnts
  #pragma kernel GEM_Lib_move_tst_Pnt_to_pnt
  #pragma kernel GEM_Lib_copy_pnts
  #pragma kernel GEM_Lib_findMaxErrorI
  #pragma kernel GEM_Lib_findMaxError
  #pragma kernel GEM_Lib_calcMaxError
  #pragma kernel GEM_Lib_initMaxError
  #pragma kernel GEM_Lib_copy_pnts_to_tst_Pnts
  #pragma kernel GEM_Lib_update_w_avg_Xs
  #pragma kernel GEM_Lib_update_best_x
  #pragma kernel GEM_Lib_update_best_Score
  #pragma kernel GEM_Lib_calc_wx
  #pragma kernel GEM_Lib_init_w
  #pragma kernel GEM_Lib_calc_sum_w
  #pragma kernel GEM_Lib_find_mn_mx_ScoreIs
  #pragma kernel GEM_Lib_find_mn_mx_Scores
  #pragma kernel GEM_Lib_inv_Scores
  #pragma kernel GEM_Lib_calc_Scores
  #pragma kernel GEM_Lib_find_search_Pnts
  #pragma kernel GEM_Lib_init_search
  #pragma kernel GEM_Lib_init_search_inputs
  #pragma kernel GEM_Lib_detectMissingEntries
  #pragma kernel GEM_Lib_initMissingEntries
  #pragma kernel GEM_Lib_copy_outputs_pntYs
  #pragma kernel GEM_Lib_copy_pntYs_outputs
  #pragma kernel GEM_Lib_copy_pntXs_inputs
  #pragma kernel GEM_Lib_unNormalize_outputs
  #pragma kernel GEM_Lib_calc_output_sums
  #pragma kernel GEM_Lib_calc_outputs_01
  #pragma kernel GEM_Lib_calc_outputs_v
  #pragma kernel GEM_Lib_calc_output_ys
  #pragma kernel GEM_Lib_zero_output_ys
  #pragma kernel GEM_Lib_zero_outputs
  #pragma kernel GEM_Lib_normalize_inputs
  #pragma kernel GEM_Lib_calc_pntHs
  #pragma kernel GEM_Lib_normalize_trn_Points
  #pragma kernel GEM_Lib_Get_ranges
  #pragma kernel GEM_Lib_Copy_Ranges_To_ranges
  #pragma kernel GEM_Lib_Find_Ranges
  #pragma kernel GEM_Lib_Init_Ranges
  #pragma kernel GEM_Lib_assign_trn_Inputs_Outputs
  #pragma kernel GEM_Lib_assign_tst_Inputs
  #pragma kernel GEM_Lib_assign_outliers
  #pragma kernel GEM_Lib_assign_K_Us
  #pragma kernel GEM_Lib_assign_unknowns
  #pragma kernel GEM_Lib_find_max_fpI
  #pragma kernel GEM_Lib_calc_max_fp
  #pragma kernel GEM_Lib_init_max_fp
  #pragma kernel GEM_Lib_calc_fp_errors
  #pragma kernel GEM_Lib_init_fp_errors
  #pragma kernel VGrid_Lib_BDraw_AppendBuff_GetIndexes
  #pragma kernel VGrid_Lib_BDraw_AppendBuff_IncSums
  #pragma kernel VGrid_Lib_BDraw_AppendBuff_IncFills1
  #pragma kernel VGrid_Lib_BDraw_AppendBuff_GetFills2
  #pragma kernel VGrid_Lib_BDraw_AppendBuff_GetFills1
  #pragma kernel VGrid_Lib_BDraw_AppendBuff_Get_Bits_Sums
  #pragma kernel VGrid_Lib_BDraw_AppendBuff_GetSums
  #pragma kernel VGrid_Lib_BDraw_AppendBuff_Get_Bits
  #pragma kernel VGrid_Lib_BDraw_setDefaultTextInfo
  #pragma kernel VGrid_Lib_BDraw_getTextInfo
  #pragma kernel VGrid_Lib_Grid_Simple_TraceRay
  #pragma kernel VGrid_Lib_Grid_TraceRay
  #pragma kernel VGrid_Lib_Grid_Calc_Vals
  #pragma kernel Rand_grp_fill_1K
  #pragma kernel Rand_grp_init_1K
  #pragma kernel Rand_grp_init_1M
  #pragma kernel GEM_Lib_Rand_grp_fill_1K
  #pragma kernel GEM_Lib_Rand_grp_init_1K
  #pragma kernel GEM_Lib_Rand_grp_init_1M
  #pragma kernel setAvgs