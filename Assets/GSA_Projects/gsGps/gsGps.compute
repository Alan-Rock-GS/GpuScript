
  #include "UnityCG.cginc"
  #include "Lighting.cginc"
  #include "../../GS/GS_Compute.cginc"
  #define ADraw_Draw_Point	0
  #define ADraw_Draw_Sphere	1
  #define ADraw_Draw_Line	2
  #define ADraw_Draw_Arrow	3
  #define ADraw_Draw_Signal	4
  #define ADraw_Draw_LineSegment	5
  #define ADraw_Draw_Texture_2D	6
  #define ADraw_Draw_Quad	7
  #define ADraw_Draw_WebCam	8
  #define ADraw_Draw_Mesh	9
  #define ADraw_Draw_Number	10
  #define ADraw_Draw_N	11
  #define ADraw_TextAlignment_BottomLeft	0
  #define ADraw_TextAlignment_CenterLeft	1
  #define ADraw_TextAlignment_TopLeft	2
  #define ADraw_TextAlignment_BottomCenter	3
  #define ADraw_TextAlignment_CenterCenter	4
  #define ADraw_TextAlignment_TopCenter	5
  #define ADraw_TextAlignment_BottomRight	6
  #define ADraw_TextAlignment_CenterRight	7
  #define ADraw_TextAlignment_TopRight	8
  #define ADraw_Text_QuadType_FrontOnly	0
  #define ADraw_Text_QuadType_FrontBack	1
  #define ADraw_Text_QuadType_Switch	2
  #define ADraw_Text_QuadType_Arrow	3
  #define ADraw_Text_QuadType_Billboard	4
  #define ADraw_Draw_Text3D 12
  #define ADraw_LF 10
  #define ADraw_TB 9
  #define ADraw_ZERO 48
  #define ADraw_NINE 57
  #define ADraw_PERIOD 46
  #define ADraw_COMMA 44
  #define ADraw_PLUS 43
  #define ADraw_MINUS 45
  #define ADraw_SPACE 32
  #define g gGps[0]
  #pragma use_dxc
  struct GGps
  {
    float2 accuracy, gpsPosition, gpsError;
    uint activate, input, output, ADraw_omitText, ADraw_includeUnicode, ADraw_fontInfoN, ADraw_textN, ADraw_textCharN, ADraw_boxEdgeN, ADraw_AAppendBuff_IndexN, ADraw_AAppendBuff_BitN, ADraw_AAppendBuff_N, ADraw_AAppendBuff_BitRowN, ADraw_AAppendBuff_BitColN;
    float gpsAltitude, ADraw_fontSize, ADraw_boxThickness;
    float4 ADraw_boxColor;
  };
  struct ADraw_FontInfo { float2 uvBottomLeft, uvBottomRight, uvTopLeft, uvTopRight; int advance, bearing, minX, minY, maxX, maxY; };
  struct ADraw_TextInfo { float3 p, right, up, p0, p1; float2 size, uvSize; float4 color, backColor; uint justification, textI, quadType, axis; float height; };
  RWStructuredBuffer<GGps> gGps;
  RWStructuredBuffer<uint> ADraw_tab_delimeted_text, ADraw_AAppendBuff_Bits, ADraw_AAppendBuff_Sums, ADraw_AAppendBuff_Indexes, ADraw_AAppendBuff_ColN_Sums;
  RWStructuredBuffer<ADraw_TextInfo> ADraw_textInfos;
  RWStructuredBuffer<ADraw_FontInfo> ADraw_fontInfos;
  [numthreads(numthreads1, 1, 1)] void ADraw_AAppendBuff_CalcIndexes(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.ADraw_AAppendBuff_BitN) { uint i = id.x, j, sum = i == 0 ? 0 : ADraw_AAppendBuff_Sums[i - 1], b, i32 = i << 5, k; for (k = 0, b = ADraw_AAppendBuff_Bits[i]; b > 0; k++) { j = (uint)findLSB(b); ADraw_AAppendBuff_Indexes[sum + k] = i32 + j; b = SetBitu(b, j, 0); } } } }
  [numthreads(numthreads2, numthreads2, 1)] void ADraw_AAppendBuff_CalcSums(uint3 id : SV_DispatchThreadID) { unchecked { if (id.y < g.ADraw_AAppendBuff_BitColN * (g.ADraw_AAppendBuff_BitColN - 1) / 2 && id.x < g.ADraw_AAppendBuff_BitRowN) { uint i = id.x, k = id.y, j = i * g.ADraw_AAppendBuff_BitColN; uint2 u = upperTriangularIndex(k, g.ADraw_AAppendBuff_BitColN) + u11 * j; if (u.x < g.ADraw_AAppendBuff_BitN && u.y < g.ADraw_AAppendBuff_BitN) InterlockedAdd(ADraw_AAppendBuff_Sums, u.y, countbits(ADraw_AAppendBuff_Bits[u.x])); } } }
  [numthreads(numthreads1, 1, 1)] void ADraw_AAppendBuff_InitSums(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.ADraw_AAppendBuff_BitN) { ADraw_AAppendBuff_Sums[id.x] = countbits(ADraw_AAppendBuff_Bits[id.x]); } } }
  [numthreads(numthreads1, 1, 1)] void ADraw_AAppendBuff_Init_Bits_32(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.ADraw_AAppendBuff_BitN) { ADraw_AAppendBuff_Bits[id.x] = 0; } } }
  uint ADraw_AAppendBuff_SumI(uint rowI, uint colJ) { return rowI * g.ADraw_AAppendBuff_BitColN + colJ; }
  [numthreads(numthreads1, 1, 1)] void ADraw_AAppendBuff_Calc_ColN_Sums(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.ADraw_AAppendBuff_BitRowN * (g.ADraw_AAppendBuff_BitRowN - 1) / 2) { uint2 u = upperTriangularIndex(id.x, g.ADraw_AAppendBuff_BitColN); if (u.x < g.ADraw_AAppendBuff_BitRowN) InterlockedAdd(ADraw_AAppendBuff_ColN_Sums, u.y, ADraw_AAppendBuff_Sums[min(ADraw_AAppendBuff_SumI(u.x, g.ADraw_AAppendBuff_BitColN - 1), g.ADraw_AAppendBuff_BitN - 1)]); } } }
  [numthreads(numthreads1, 1, 1)] void ADraw_AAppendBuff_Init_ColN_Sums(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.ADraw_AAppendBuff_BitRowN) { ADraw_AAppendBuff_ColN_Sums[id.x] = ADraw_AAppendBuff_Sums[min(ADraw_AAppendBuff_SumI(id.x, g.ADraw_AAppendBuff_BitColN - 1), g.ADraw_AAppendBuff_BitN - 1)]; } } }
  ADraw_TextInfo ADraw_textInfo(uint i) { return ADraw_textInfos[i]; }
  void ADraw_textInfo(uint i, ADraw_TextInfo t) { ADraw_textInfos[i] = t; }
  [numthreads(numthreads1, 1, 1)] void ADraw_setDefaultTextInfo(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.ADraw_textN)
    {
      uint i = id.x;
      if (i > 0)
      {
        ADraw_TextInfo t = ADraw_textInfo(0), ti = ADraw_textInfo(i);
        ti.color = t.color; ti.backColor = t.backColor; ti.p = t.p; ti.p0 = t.p0; ti.p1 = t.p1; ti.height = t.height;
        ti.quadType = (uint)t.quadType; ti.axis = t.axis; ti.right = t.right; ti.up = t.up; ti.justification = t.justification;
        ADraw_textInfo(i, ti);
      }
    }
    }
  }
  uint2 ADraw_Get_text_indexes(uint textI) { return uint2(textI == 0 ? 0 : ADraw_AAppendBuff_Indexes[textI - 1] + 1, textI < g.ADraw_AAppendBuff_IndexN ? ADraw_AAppendBuff_Indexes[textI] : g.ADraw_textCharN); }
  uint ADraw_Byte(uint i) { return TextByte(ADraw_tab_delimeted_text, i); }
  [numthreads(numthreads1, 1, 1)] void ADraw_getTextInfo(uint3 id : SV_DispatchThreadID)
  {
    unchecked
    {
      if (id.x < g.ADraw_textN)
    {
      uint i = id.x;
      ADraw_TextInfo ti = ADraw_textInfo(i);
      ti.textI = i;
      ti.uvSize = f01;
      uint2 textIs = ADraw_Get_text_indexes(i);
      float2 t = ti.uvSize;
      for (uint j = textIs.x; j < textIs.y; j++) { uint byteI = ADraw_Byte(j); if (byteI >= 32) { byteI -= 32; t.x += ADraw_fontInfos[byteI].advance; } }
      t.x /= g.ADraw_fontSize;
      ti.uvSize = t;
      ADraw_textInfo(i, ti);
    }
    }
  }
  bool ADraw_AAppendBuff_IsBitOn(uint i) { uint c = ADraw_Byte(i); return c == ADraw_TB || c == ADraw_LF; }
  uint ADraw_AAppendBuff_Assign_Bit(uint i, uint j) { return Is(i < g.ADraw_AAppendBuff_N && ADraw_AAppendBuff_IsBitOn(i)) << (int)j; }
  [numthreads(numthreads2, numthreads2, 1)] void ADraw_AAppendBuff_Get_Bits_32(uint3 id : SV_DispatchThreadID) { unchecked { if (id.y < 32 && id.x < g.ADraw_AAppendBuff_BitN) { uint i = id.x, j = id.y, k = i * 32 + j, bits; if (i < g.ADraw_AAppendBuff_BitN && (bits = ADraw_AAppendBuff_Assign_Bit(k, j)) != 0) InterlockedOr(ADraw_AAppendBuff_Bits, i, bits); } } }
  uint ADraw_AAppendBuff_Assign_Bits(uint i, uint j, uint bits) { return bits | ADraw_AAppendBuff_Assign_Bit(i, j); }
  [numthreads(numthreads1, 1, 1)] void ADraw_AAppendBuff_Get_Bits(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.ADraw_AAppendBuff_BitN) { uint i = id.x, j, k, bits = 0; if (i < g.ADraw_AAppendBuff_BitN) { for (j = 0, k = i * 32; j < 32; j++) bits = ADraw_AAppendBuff_Assign_Bits(k + j, j, bits); ADraw_AAppendBuff_Bits[i] = bits; } } } }
  [numthreads(numthreads2, numthreads2, 1)] void ADraw_AAppendBuff_Add_ColN_Sums(uint3 id : SV_DispatchThreadID) { unchecked { if (id.y < g.ADraw_AAppendBuff_BitColN && id.x < g.ADraw_AAppendBuff_BitRowN - 1) { uint rowI = id.x + 1, i = ADraw_AAppendBuff_SumI(rowI, id.y); if (i < g.ADraw_AAppendBuff_BitN) InterlockedAdd(ADraw_AAppendBuff_Sums, i, ADraw_AAppendBuff_ColN_Sums[rowI - 1]); } } }
  #pragma kernel ADraw_AAppendBuff_CalcIndexes
  #pragma kernel ADraw_AAppendBuff_Add_ColN_Sums
  #pragma kernel ADraw_AAppendBuff_Calc_ColN_Sums
  #pragma kernel ADraw_AAppendBuff_Init_ColN_Sums
  #pragma kernel ADraw_AAppendBuff_CalcSums
  #pragma kernel ADraw_AAppendBuff_InitSums
  #pragma kernel ADraw_AAppendBuff_Get_Bits_32
  #pragma kernel ADraw_AAppendBuff_Init_Bits_32
  #pragma kernel ADraw_AAppendBuff_Get_Bits
  #pragma kernel ADraw_setDefaultTextInfo
  #pragma kernel ADraw_getTextInfo