
  #include "UnityCG.cginc"
  #include "Lighting.cginc"
  #include "../../GS/GS_Compute.cginc"
  #define nSize 1024
  #define g gAtomic[0]
  #pragma use_dxc
  struct GAtomic
  {
    uint MatRowN, MatN, printMatrices, numberOfArrays, arrayLength, sortVN, NumN, IterN, uintN, sumN, Rand_N, Rand_I, Rand_J;
    uint2 factN_range;
    uint4 Rand_seed4;
  };
  struct MatrixRuntime { uint runtime_Compute, runtime_printMatrices; string runtime_Name; uint runtime_MatRowN, runtime_MatN, runtime_error; float runtime_min_us, runtime_med_us, runtime_avg_us, runtime_max_us, runtime_xFaster; string runtime_xTime; };
  struct SortRuntime { uint runtime_Compute; string runtime_Name; uint runtime_error; float runtime_runtime_us, runtime_xFaster; string runtime_xTime; };
  struct SortTimeComplexity { uint order_size; float order_gpu_us, order_linq_us, order_xFaster; string order_xTime, order_gpu_time_complexity, order_cpu_time_complexity; };
  groupshared uint4 Rand_grp[1024];
  groupshared int gA[1024];
  groupshared int gx[1024];
  groupshared int gb[1024];
  groupshared float gf[1024];
  groupshared uint gcounts[1024];
  groupshared uint gsorts[1024];
  RWStructuredBuffer<GAtomic> gAtomic;
  RWStructuredBuffer<int> Mat_A, Mat_x, Mat_b;
  RWStructuredBuffer<uint> syncCount, counts, sorts, globalSyncs, uints;
  RWStructuredBuffer<float> sortVs, Mat_A_Float, Mat_x_Float, Mat_b_Float;
  RWStructuredBuffer<uint4> Rand_rs;
  RWStructuredBuffer<double> Mat_A_Double, Mat_x_Double, Mat_b_Double;
  [numthreads(numthreads1, 1, 1)] void Calc_Double_Min_Max_Sum(uint3 id : SV_DispatchThreadID)
	{
		unchecked
		{
			if (id.x < g.NumN) { int i = (int)id.x; InterlockedMin_D(uints, 0, i); InterlockedMax_D(uints, 1, i); InterlockedAdd_D(uints, 2, 1); }
		}
	}
  [numthreads(numthreads1, 1, 1)] void Calc_Min_Max_Sum(uint3 id : SV_DispatchThreadID)
	{
		unchecked
		{
			if (id.x < g.NumN) { int i = (int)id.x; InterlockedMin_F(uints, 0, i); InterlockedMax_F(uints, 1, i); InterlockedAdd_F(uints, 2, 1); }
		}
	}
  [numthreads(numthreads1, 1, 1)] void Init_Min_Max_Sum(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < 3) { uints[id.x] = id.x == 0 ? asuint(fPosInf) : id.x == 1 ? asuint(fNegInf) : asuint(0); } } }
  [numthreads(numthreads1, 1, 1)] void calc_dsums(uint3 id : SV_DispatchThreadID)
	{
		unchecked
		{
			if (id.x < triN(g.sumN)) { uint N = g.sumN; uint2 v = N - triI(id.x, N) + i_1; double vy = v.y; InterlockedAdd_D(uints, v.x, vy); }
		}
	}
  [numthreads(numthreads1, 1, 1)] void calc_isums(uint3 id : SV_DispatchThreadID)
	{
		unchecked
		{
			if (id.x < triN(g.sumN)) { uint N = g.sumN; uint2 v = N - triI(id.x, N) + i_1; float vy = v.y; InterlockedAdd_F(uints, v.x, vy); }
		}
	}
  [numthreads(numthreads1, 1, 1)] void calc_lsums(uint3 id : SV_DispatchThreadID)
	{
		unchecked
		{
			if (id.x < triN(g.sumN)) { uint N = g.sumN; uint2 v = N - triI(id.x, N) + i_1; InterlockedAdd_Long(uints, v.x, (long)v.y); }
		}
	}
  [numthreads(numthreads1, 1, 1)] void calc_usums(uint3 id : SV_DispatchThreadID)
	{
		unchecked
		{
			if (id.x < triN(g.sumN)) { uint N = g.sumN; uint2 v = N - triI(id.x, N) + i_1; InterlockedAdd(uints, v.x, v.y); }
		}
	}
  [numthreads(numthreads1, 1, 1)] void calc_dfacts(uint3 id : SV_DispatchThreadID)
	{
		unchecked
		{
			if (id.x < triN(g.factN_range.y)) { uint N = g.factN_range.y; uint2 v = N - triI(id.x, N) + i_1; float vy = v.y; InterlockedMul_D(uints, v.x, vy); }
		}
	}
  [numthreads(numthreads1, 1, 1)] void calc_ifacts_Test(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex) { uint N = g.factN_range.y; uint2 v = N - triI(id.x, N) + i_1; float vy = v.y; InterlockedMul_F(uints, v.x, vy); }
	
  [numthreads(numthreads1, 1, 1)] void calc_ifacts(uint3 id : SV_DispatchThreadID)
	{
		unchecked
		{
			if (id.x < triN(g.factN_range.y)) { uint N = g.factN_range.y; uint2 v = N - triI(id.x, N) + i_1; float vy = v.y; InterlockedMul_F(uints, v.x, vy); }
		}
	}
  [numthreads(numthreads1, 1, 1)] void calc_lfacts(uint3 id : SV_DispatchThreadID)
	{
		unchecked
		{
			if (id.x < triN(g.factN_range.y)) { uint N = g.factN_range.y; uint2 v = N - triI(id.x, N) + i_1; InterlockedMul_Long(uints, v.x, (long)v.y); }
		}
	}
  [numthreads(numthreads1, 1, 1)] void init_float_uints_0(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.uintN) { uints[id.x] = asuint(0.0f); } } }
  [numthreads(numthreads1, 1, 1)] void init_float_uints_1(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.uintN) { uints[id.x] = asuint(1.0f); } } }
  [numthreads(numthreads1, 1, 1)] void init_uints_1(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.uintN) { uints[id.x] = 1; } } }
  [numthreads(numthreads2, numthreads2, 1)] void set_sorts(uint3 id : SV_DispatchThreadID)
	{
		unchecked
		{
			if (id.y < g.arrayLength && id.x < g.numberOfArrays) { uint segI = id.x, sortI = id.y, j = segI * g.arrayLength, i = j + sortI; sorts[j + counts[i]] = sortI; }
		}
	}
  [numthreads(numthreads3, numthreads3, numthreads3)] void add_counts(uint3 id : SV_DispatchThreadID)
	{
		unchecked
		{
			if (id.z < g.arrayLength && id.y < g.arrayLength && id.x < g.numberOfArrays) { uint i = id.x * g.arrayLength, i0 = i + id.y, i1 = i + id.z; if (sortVs[i0] > sortVs[i1]) InterlockedAdd(counts, i0, 1); }
		}
	}
  [numthreads(numthreads2, numthreads2, 1)] void add_counts_triangle(uint3 id : SV_DispatchThreadID)
	{
		unchecked
		{
			if (id.y < g.arrayLength * (g.arrayLength - 1) / 2 && id.x < g.numberOfArrays)
			{
				uint segI = id.x, k = id.y, j = segI * g.arrayLength;
				uint2 u = upperTriangularIndex(k, g.arrayLength) + u11 * j;
				InterlockedAdd(counts, sortVs[u.x] > sortVs[u.y] ? u.x : u.y, 1);
			}
		}
	}
  [numthreads(numthreads1, 1, 1)] void init_counts(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.sortVN) { counts[id.x] = 0; } } }
  [numthreads(numthreads1, 1, 1)] void Rand_initSeed(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.Rand_N) { uint i = id.x; Rand_rs[i] = i == 0 ? g.Rand_seed4 : u0000; } } }
  [numthreads(numthreads1, 1, 1)] void Rand_grp_fill_1K(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex) { null; }
  [numthreads(numthreads1, 1, 1)] void Rand_grp_init_1K(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex) { null; }
   
  [numthreads(numthreads1, 1, 1)] void Rand_grp_init_1M(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex) { null; }
   
  [numthreads(numthreads3, numthreads3, numthreads3)] void A_times_x(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex) { null; }
   
  void set_uints(uint i, uint2 u) { uints[i * 2] = u.x; uints[i * 2 + 1] = u.y; }
	
  [numthreads(numthreads1, 1, 1)] void init_long_uints_1(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.uintN) { set_uints(id.x, long_to_uint2(1)); } } }
  uint2 double_to_uint2(double v) { uint a, b; asuint(v, a, b); return uint2(a, b); }
  [numthreads(numthreads1, 1, 1)] void init_double_uints_0(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.uintN) { set_uints(id.x, double_to_uint2(0.0f)); } } }
  [numthreads(numthreads1, 1, 1)] void init_double_uints_1(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.uintN) { set_uints(id.x, double_to_uint2(1.0f)); } } }
  bool CalcFact(uint I, uint v, uint x, uint y) { bool ok = I >= x && v > x && I < y && v <= y; if (ok) InterlockedMul(uints, I, v); return ok; }
	
  [numthreads(numthreads1, 1, 1)] void calc_ufacts(uint3 id : SV_DispatchThreadID)
	{
		unchecked
		{
			if (id.x < triN(g.factN_range.y)) { uint N = g.factN_range.y; uint2 v = N - triI(id.x, N) + i_1; uint f[] = { 0, 12, 19, 26, 32, 38, 43, 48, 53, 58 }; for (uint i = 0; i < 9 && !CalcFact(v.x, v.y, f[i], f[i + 1]);) i++; }
		}
	}
  float GetSortV(uint arrayI, uint itemI) { return itemI == 0 ? g.arrayLength - 2 : itemI == 1 ? g.arrayLength - 1 : g.arrayLength - 1 - itemI; }
  uint MatA_Index(uint2 ij) { return id_to_i(ij, g.MatRowN, g.MatRowN); }
  uint SortI(uint arrayI, uint itemI) { return arrayI * g.arrayLength + itemI; }
  void SortV(uint arrayI, uint itemI, float v) { sortVs[SortI(arrayI, itemI)] = v; }
  [numthreads(numthreads1, 1, 1)] void GrpSort(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
	{
		uint i = id.x / nSize, j = id.x % nSize;
		if (i < g.numberOfArrays && j < g.arrayLength)
		{
			gf[j] = GetSortV(i, j); gcounts[j] = 0; GrpSync();
			for (uint k = j + 1; k < g.arrayLength; k++) InterlockedAdd(gcounts, gf[j] > gf[k] ? j : k, 1); GrpSync();
			gsorts[gcounts[j]] = j; GrpSync();
			SortV(i, j, gf[gsorts[j]]);
		}
	}
	
  uint Mat_Index(uint colI, uint rowJ) { return id_to_i(colI, rowJ, g.MatN, g.MatRowN); }
  uint Mat_Index(uint2 ij) { return Mat_Index(ij.x, ij.y); }
  int Matx(uint colI, uint rowJ) { return Mat_x[Mat_Index(colI, rowJ)]; }
  int Matb(uint colI, uint rowJ) { return Mat_b[Mat_Index(colI, rowJ)]; }
  void Matb(uint colI, uint rowJ, int V) { Mat_b[Mat_Index(colI, rowJ)] = V; }
  [numthreads(numthreads2, numthreads2, 1)] void Init_Mat_b(uint3 id : SV_DispatchThreadID) { unchecked { if (id.y < g.MatRowN && id.x < g.MatN) { Matb(id.x, id.y, 0); } } }
  void Matb(uint2 ij, int V) { Matb(ij.x, ij.y, V); }
  void Matx(uint colI, uint rowJ, int V) { Mat_x[Mat_Index(colI, rowJ)] = V; }
  [numthreads(numthreads2, numthreads2, 1)] void Init_Mat_x(uint3 id : SV_DispatchThreadID) { unchecked { if (id.y < g.MatRowN && id.x < g.MatN) { Matx(id.x, id.y, 1); } } }
  void Matx(uint2 ij, int V) { Matx(ij.x, ij.y, V); }
  int Matx(uint2 ij) { return Matx(ij.x, ij.y); }
  uint MatA_Index(uint colI, uint rowJ) { return MatA_Index(uint2(colI, rowJ)); }
  int MatA(uint i, uint j) { return Mat_A[MatA_Index(i, j)]; }
  void MatA(uint i, uint j, int V) { Mat_A[MatA_Index(i, j)] = V; }
  [numthreads(numthreads2, numthreads2, 1)] void Init_Mat_A(uint3 id : SV_DispatchThreadID) { unchecked { if (id.y < g.MatRowN && id.x < g.MatRowN) { MatA(id.x, id.y, 1); } } }
  [numthreads(numthreads2, numthreads2, 1)] void Init_Axb(uint3 id : SV_DispatchThreadID)
	{
		unchecked
		{
			if (id.y < g.MatRowN && id.x < g.MatRowN) { MatA(id.x, id.y, 1); Matx(id.x, id.y, 1); Matb(id.x, id.y, 0); }
		}
	}
  void MatA(uint2 ij, int V) { MatA(ij.x, ij.y, V); }
  [numthreads(numthreads1, 1, 1)] void Grp_Multiply_Ax(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
	{
		uint i = id.x, tI = grp_tid.x, gI = grp_id.x;
		gA[tI] = MatA(tI, gI);
		gx[tI] = Matx(0, tI); gb[tI] = 0;
		GrpSync();
		InterlockedAdd(gb, gI, gA[tI] * gx[tI]);
		GrpSync();
		Matb(gI, tI, gb[gI]);
	}
	
  int MatA(uint2 ij) { return MatA(ij.x, ij.y); }
  [numthreads(numthreads3, numthreads3, numthreads3)] void Global_A_x(uint3 grp_tid : SV_GroupThreadID, uint3 grp_id : SV_GroupID, uint3 id : SV_DispatchThreadID, uint grpI : SV_GroupIndex)
	{
		uint i = id_to_i(id, uint3(g.MatRowN, g.MatRowN, g.MatN)), An = g.MatRowN * g.MatRowN, xN = An + g.MatRowN * g.MatN, bN = xN + g.MatRowN * g.MatN, n = bN,
			s0 = globalSyncs[n], s1 = s0 + 1, Ai = MatA_Index(id.xy), xi = An + Mat_Index(id.zx), bi = xN + Mat_Index(id.zx);
		if (id.z == 0)
		{
			MatA(id.xy, 1);
			globalSyncs[Ai] = s1;
		}
		if (id.x == 0)
		{
			Matx(id.yz, 1);
			globalSyncs[xi] = s1;
			Matb(id.yz, 0);
			globalSyncs[bi] = s1;
		}
		while (globalSyncs[Ai] != s1 || globalSyncs[xi] != s1 || globalSyncs[bi] != s1)
		{
			InterlockedAdd(globalSyncs, Ai, 0);
			InterlockedAdd(globalSyncs, xi, 0);
			InterlockedAdd(globalSyncs, bi, 0);
			GrpSync();
		}
		GrpSync();
		InterlockedAdd(Mat_b, Mat_Index(id.zx), MatA(id.xy) * Matx(id.zx));
		GrpSync();
	}
	
  [numthreads(numthreads3, numthreads3, numthreads3)] void Multiply_Mat_A_x(uint3 id : SV_DispatchThreadID) { unchecked { if (id.z < g.MatN && id.y < g.MatRowN && id.x < g.MatRowN) { InterlockedAdd(Mat_b, Mat_Index(id.zx), MatA(id.xy) * Matx(id.zx)); } } }
  [numthreads(numthreads3, numthreads3, numthreads3)] void Multiply_Double_A_x(uint3 id : SV_DispatchThreadID) { unchecked { if (id.z < g.MatN && id.y < g.MatRowN && id.x < g.MatRowN) { InterlockedAdd_D(uints, Mat_Index(id.zx), MatA(id.xy) * Matx(id.zx)); } } }
  [numthreads(numthreads3, numthreads3, numthreads3)] void Multiply_Float_A_x(uint3 id : SV_DispatchThreadID) { unchecked { if (id.z < g.MatN && id.y < g.MatRowN && id.x < g.MatRowN) { InterlockedAdd_F(uints, Mat_Index(id.zx), MatA(id.xy) * Matx(id.zx)); } } }
  uint Rand_UV(uint4 r) { return cxor(r); }
  float Rand_FV(uint4 r) { return 2.3283064365387e-10f * Rand_UV(r); }
  uint Rand_u(uint a, int b, int c, int d, uint e) { return ((a & e) << d) ^ (((a << b) ^ a) >> c); }
  uint4 Rand_U4(uint4 r) { return uint4(Rand_u(r.x, 13, 19, 12, 4294967294u), Rand_u(r.y, 2, 25, 4, 4294967288u), Rand_u(r.z, 3, 11, 17, 4294967280u), r.w * 1664525 + 1013904223u); }
  uint4 Rand_rUInt4(uint i) { return Rand_U4(Rand_rs[i]); }
  uint4 Rand_UInt4(uint i) { return Rand_rs[i] = Rand_rUInt4(i); }
  float Rand_Float(uint i) { return Rand_FV(Rand_UInt4(i)); }
  [numthreads(numthreads1, 1, 1)] void init_vs(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.sortVN) { sortVs[id.x] = Rand_Float(id.x); } } }
  float Rand_Float(uint i, float A, float B) { return lerp(A, B, Rand_Float(i)); }
  uint Rand_UInt(uint i, uint A, uint B) { return flooru(Rand_Float(i, A, B)); }
  [numthreads(numthreads1, 1, 1)] void Rand_initState(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < g.Rand_I) { uint i = id.x + g.Rand_I; if (i < g.Rand_N) Rand_rs[i] = index(Rand_rs[i], g.Rand_J, Rand_UInt(id.x, 0, uint_max)); } } }
  [numthreads(numthreads1, 1, 1)] void Init_Double_Min_Max_Sum(uint3 id : SV_DispatchThreadID) { unchecked { if (id.x < 3) { set_uints(id.x, id.x == 0 ? double_to_uint2(fPosInf) : id.x == 1 ? double_to_uint2(fNegInf) : double_to_uint2(0)); } } }
  #pragma kernel Calc_Double_Min_Max_Sum
  #pragma kernel Init_Double_Min_Max_Sum
  #pragma kernel Calc_Min_Max_Sum
  #pragma kernel Init_Min_Max_Sum
  #pragma kernel calc_dsums
  #pragma kernel calc_isums
  #pragma kernel calc_lsums
  #pragma kernel calc_usums
  #pragma kernel calc_dfacts
  #pragma kernel calc_ifacts_Test
  #pragma kernel calc_ifacts
  #pragma kernel calc_lfacts
  #pragma kernel calc_ufacts
  #pragma kernel init_double_uints_0
  #pragma kernel init_float_uints_0
  #pragma kernel init_double_uints_1
  #pragma kernel init_float_uints_1
  #pragma kernel init_long_uints_1
  #pragma kernel init_uints_1
  #pragma kernel set_sorts
  #pragma kernel add_counts
  #pragma kernel add_counts_triangle
  #pragma kernel init_counts
  #pragma kernel init_vs
  #pragma kernel GrpSort
  #pragma kernel Global_A_x
  #pragma kernel Multiply_Mat_A_x
  #pragma kernel Init_Mat_b
  #pragma kernel Init_Mat_x
  #pragma kernel Init_Mat_A
  #pragma kernel Multiply_Double_A_x
  #pragma kernel Multiply_Float_A_x
  #pragma kernel Grp_Multiply_Ax
  #pragma kernel Init_Axb
  #pragma kernel Rand_initState
  #pragma kernel Rand_initSeed
  #pragma kernel Rand_grp_fill_1K
  #pragma kernel Rand_grp_init_1K
  #pragma kernel Rand_grp_init_1M
  #pragma kernel A_times_x